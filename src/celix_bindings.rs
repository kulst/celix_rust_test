/* automatically generated by rust-bindgen 0.66.1 */

pub const _ERRNO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const CELIX_CUSTOMER_ERR_MASK: u32 = 536870912;
pub const CELIX_FACILITY_CERRNO: u32 = 0;
pub const CELIX_FACILITY_FRAMEWORK: u32 = 1;
pub const CELIX_FACILITY_HTTP: u32 = 2;
pub const CELIX_FACILITY_ZIP: u32 = 3;
pub const CELIX_FACILITY_CURL: u32 = 4;
pub const CELIX_SUCCESS: u32 = 0;
pub const CELIX_START_ERROR: u32 = 70000;
pub const CELIX_ERRSPACE_SIZE: u32 = 1000;
pub const CELIX_START_USERERR: u32 = 71000;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const CELIX_SHELL_COMMAND_NAME: &[u8; 13] = b"command.name\0";
pub const CELIX_SHELL_COMMAND_USAGE: &[u8; 14] = b"command.usage\0";
pub const CELIX_SHELL_COMMAND_DESCRIPTION: &[u8; 20] = b"command.description\0";
pub const CELIX_SHELL_COMMAND_SERVICE_NAME: &[u8; 20] = b"celix_shell_command\0";
pub const CELIX_SHELL_COMMAND_SERVICE_VERSION: &[u8; 6] = b"1.0.0\0";
pub const CELIX_LOG_SERVICE_NAME: &[u8; 18] = b"celix_log_service\0";
pub const CELIX_LOG_SERVICE_VERSION: &[u8; 6] = b"1.0.0\0";
pub const CELIX_LOG_SERVICE_USE_RANGE: &[u8; 10] = b"[1.0.0,2)\0";
pub const CELIX_LOG_SERVICE_PROPERTY_NAME: &[u8; 5] = b"name\0";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[doc = " \\defgroup celix_errno Error Codes\n \\ingroup framework\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_status {
    pub code: ::std::os::raw::c_int,
    pub error: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_celix_status() {
    const UNINIT: ::std::mem::MaybeUninit<celix_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_status>(),
        16usize,
        concat!("Size of: ", stringify!(celix_status))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_status>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_status),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_status),
            "::",
            stringify!(error)
        )
    );
}
#[doc = " Status type returned by all functions in Celix"]
pub type celix_status_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Return a readable string for the given status code."]
    pub fn celix_strerror(status: celix_status_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Check if a provided celix_status_t is from a specific facility.\n @param[in] code The status code to check.\n @param[in] fac The facility to check against.\n @return true if the status is from the provided facility, false otherwise."]
    pub fn celix_utils_isStatusCodeFromFacility(
        code: celix_status_t,
        fac: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if a provided celix_status_t is a customer error code.\n @param[in] code The status code to check.\n @return true if the status is a customer error code, false otherwise."]
    pub fn celix_utils_isCustomerStatusCode(code: celix_status_t) -> bool;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_properties {
    _unused: [u8; 0],
}
#[doc = " @brief The Apache Celix properties type."]
pub type celix_properties_t = celix_properties;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_version {
    _unused: [u8; 0],
}
#[doc = " @brief The definition of the celix_version_t* abstract data type."]
pub type celix_version_t = celix_version;
extern "C" {
    #[doc = " @brief Create a new celix_version_t* using the supplied arguments.\n\n If the return is NULL, an error message is logged to celix_err.\n\n @param[in] major Major component of the version identifier.\n @param[in] minor Minor component of the version identifier.\n @param[in] micro Micro component of the version identifier.\n @param[in] qualifier Qualifier component of the version identifier. If\n        <code>NULL</code> is specified, then the qualifier will be set to\n        the empty string.\n @return The created version or NULL if the input was incorrect or memory could not be allocated."]
    pub fn celix_version_create(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        micro: ::std::os::raw::c_int,
        qualifier: *const ::std::os::raw::c_char,
    ) -> *mut celix_version_t;
}
extern "C" {
    #[doc = " @brief Destroy a celix_version_t*.\n @param version The version to destroy."]
    pub fn celix_version_destroy(version: *mut celix_version_t);
}
pub type celix_version_t_autoptr = *mut celix_version_t;
extern "C" {
    #[doc = " @brief Create a copy of <code>version</code>.\n\n If the provided version is NULL a NULL pointer is returned.\n If the return is NULL, an error message is logged to celix_err.\n\n @param[in] version The version to copy\n @return the copied version"]
    pub fn celix_version_copy(version: *const celix_version_t) -> *mut celix_version_t;
}
extern "C" {
    #[doc = " @brief Create a version identifier from the specified string.\n\n <p>\n Here is the grammar for version strings.\n\n <pre>\n version ::= major('.'minor('.'micro('.'qualifier)?)?)?\n major ::= digit+\n minor ::= digit+\n micro ::= digit+\n qualifier ::= (alpha|digit|'_'|'-')+\n digit ::= [0..9]\n alpha ::= [a..zA..Z]\n </pre>\n\n There must be no whitespace in version.\n\n If the return is NULL, an error message is logged to celix_err.\n\n @param[in] versionStr String representation of the version identifier.\n @return The created version or NULL if the input was invalid or memory could not be allocated."]
    pub fn celix_version_createVersionFromString(
        versionStr: *const ::std::os::raw::c_char,
    ) -> *mut celix_version_t;
}
extern "C" {
    #[doc = " @brief Parse a version string into a version object.\n\n <p>\n Here is the grammar for version strings.\n\n <pre>\n version ::= major('.'minor('.'micro('.'qualifier)?)?)?\n major ::= digit+\n minor ::= digit+\n micro ::= digit+\n qualifier ::= (alpha|digit|'_'|'-')+\n digit ::= [0..9]\n alpha ::= [a..zA..Z]\n </pre>\n\n If the return is NULL, an error message is logged to celix_err.\n\n @param[in] versionStr The version string to parse.\n @param[out] version The parsed version object.\n @return CELIX_SUCCESS if the version string was parsed successfully, CELIX_ILLEGAL_ARGUMENT if the version string\n         was invalid, or CELIX_ENOMEM if memory could not be allocated."]
    pub fn celix_version_parse(
        versionStr: *const ::std::os::raw::c_char,
        version: *mut *mut celix_version_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Create empty version \"0.0.0\"."]
    pub fn celix_version_createEmptyVersion() -> *mut celix_version_t;
}
extern "C" {
    #[doc = " @brief Gets the major version number of a celix version.\n\n @param[in] version The celix version.\n @return The major version number."]
    pub fn celix_version_getMajor(version: *const celix_version_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the minor version number of a celix version.\n\n @param[in] version The celix version.\n @return The minor version number."]
    pub fn celix_version_getMinor(version: *const celix_version_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the micro version number of a celix version.\n\n @param[in] version The celix version.\n @return The micro version number."]
    pub fn celix_version_getMicro(version: *const celix_version_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets the version qualifier of a celix version.\n\n @param[in] version The celix version.\n @return The version qualifier, or an empty string (\"\") if no qualifier is present."]
    pub fn celix_version_getQualifier(
        version: *const celix_version_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Compare this <code>Version</code> object to another object.\n\n <p>\n A version is considered to be <b>less than </b> another version if its\n major component is less than the other version's major component, or the\n major components are equal and its minor component is less than the other\n version's minor component, or the major and minor components are equal\n and its micro component is less than the other version's micro component,\n or the major, minor and micro components are equal and it's qualifier\n component is less than the other version's qualifier component (using\n <code>String.compareTo</code>).\n\n <p>\n A version is considered to be <b>equal to</b> another version if the\n major, minor and micro components are equal and the qualifier component\n is equal (using <code>String.compareTo</code>).\n\n @param version The <code>celix_version_t*</code> to be compared with <code>compare</code>.\n @param compare The <code>celix_version_t*</code> to be compared with <code>version</code>.\n @return A negative integer, zero, or a positive integer if <code>version</code> is\n         less than, equal to, or greater than the <code>compare</code>."]
    pub fn celix_version_compareTo(
        version: *const celix_version_t,
        compare: *const celix_version_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a hash of the version"]
    pub fn celix_version_hash(version: *const celix_version_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Return the string representation of <code>version</code> identifier.\n\n The format of the version string will be <code>major.minor.micro</code>\n if qualifier is the empty string or\n <code>major.minor.micro.qualifier</code> otherwise.\n\n If the return is NULL, an error message is logged to celix_err.\n\n @return The string representation of this version identifier.\n @param version The <code>celix_version_t*</code> to get the string representation from.\n @return Pointer to the string (char *) in which the result will be placed. Caller is owner of the string.\n         NULL if memory could not be allocated."]
    pub fn celix_version_toString(version: *const celix_version_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Fill a given string with the string representation of the given version.\n\n @param[in] version The version to fill the string with.\n @param[out] str The string to fill.\n @param[in] strLen The length of the string.\n @return true if the string was filled successfully, false otherwise."]
    pub fn celix_version_fillString(
        version: *const celix_version_t,
        str_: *mut ::std::os::raw::c_char,
        strLen: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if two versions are semantically compatible.\n\n <p>\n The user version is compatible with the provider version if the provider version is in the range\n [user_version, next_major_from_user_version)\n\n @param version The user <code>celix_version_t*</code> .\n @param version The reference provider <code>celix_version_t*</code> .\n @return Boolean indicating if the versions are compatible"]
    pub fn celix_version_isCompatible(
        user: *const celix_version_t,
        provider: *const celix_version_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if two versions are semantically compatible.\n\n <p>\n The user version is compatible with the provider version if the provider version is in the range\n [user_version, next_major_from_user_version)\n\n @param version The user <code>celix_version_t*</code> .\n @param providerMajorVersionPart The major part of the provider version\n @param provideMinorVersionPart The minor part of the provider version\n @return Boolean indicating if the versions are compatible"]
    pub fn celix_version_isUserCompatible(
        user: *const celix_version_t,
        providerMajorVersionPart: ::std::os::raw::c_int,
        provideMinorVersionPart: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Compare a provider celix version is with a provided major and minor version. Ignoring the patch version part.\n\n @param version The version to compare.\n @param majorVersionPart The major version part to compare.\n @param minorVersionPart The minor version part to compare.\n @return A negative integer, zero, or a positive integer if <code>version</code> is\n         less than, equal to, or greater than the <code>majorVersionPart</code> and <code>minorVersionPart</code>."]
    pub fn celix_version_compareToMajorMinor(
        version: *const celix_version_t,
        majorVersionPart: ::std::os::raw::c_int,
        minorVersionPart: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Represents an undefined element type."]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED:
    celix_array_list_element_type = 0;
#[doc = "< Represents a pointer element type."]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_POINTER:
    celix_array_list_element_type = 1;
#[doc = "< Represents a string element type where the array list is the owner"]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING:
    celix_array_list_element_type = 2;
#[doc = "< Represents a long integer element type."]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_LONG:
    celix_array_list_element_type = 3;
#[doc = "< Represents a double element type."]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_DOUBLE:
    celix_array_list_element_type = 4;
#[doc = "< Represents a boolean element type."]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_BOOL:
    celix_array_list_element_type = 5;
#[doc = "< Represents a celix_version_t* element type."]
pub const celix_array_list_element_type_CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION:
    celix_array_list_element_type = 6;
#[doc = " @enum celix_array_list_element_type_t\n @brief An enumeration of the types of elements that can be stored in a Celix array list."]
pub type celix_array_list_element_type = ::std::os::raw::c_uint;
#[doc = " @enum celix_array_list_element_type_t\n @brief An enumeration of the types of elements that can be stored in a Celix array list."]
pub use self::celix_array_list_element_type as celix_array_list_element_type_t;
#[doc = " @union celix_array_list_entry\n @brief A union representing an entry in a Celix array list.\n\n This union can hold different types of values, including pointers, strings, integers, long integers,\n unsigned integers, unsigned long integers, doubles, floats, booleans, and size_t values."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union celix_array_list_entry {
    #[doc = "< A pointer value when the element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_PTR or\nCELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub voidPtrVal: *mut ::std::os::raw::c_void,
    #[doc = "< A string value when the element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING,\nCELIX_ARRAY_LIST_ELEMENT_TYPE_STRING_REF or CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub stringVal: *const ::std::os::raw::c_char,
    #[doc = "< A long integer value when the element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_LONG or\nCELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub longVal: ::std::os::raw::c_long,
    #[doc = "< A double value when the element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_DOUBLE or\nCELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub doubleVal: f64,
    #[doc = "< A boolean value when the element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_BOOL or\nCELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub boolVal: bool,
    #[doc = "< A celix_version_t* value when the element type is\nCELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION or CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub versionVal: *const celix_version_t,
}
#[test]
fn bindgen_test_layout_celix_array_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<celix_array_list_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_array_list_entry>(),
        8usize,
        concat!("Size of: ", stringify!(celix_array_list_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_array_list_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_array_list_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voidPtrVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_entry),
            "::",
            stringify!(voidPtrVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stringVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_entry),
            "::",
            stringify!(stringVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).longVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_entry),
            "::",
            stringify!(longVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubleVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_entry),
            "::",
            stringify!(doubleVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_entry),
            "::",
            stringify!(boolVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionVal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_entry),
            "::",
            stringify!(versionVal)
        )
    );
}
#[doc = " @union celix_array_list_entry\n @brief A union representing an entry in a Celix array list.\n\n This union can hold different types of values, including pointers, strings, integers, long integers,\n unsigned integers, unsigned long integers, doubles, floats, booleans, and size_t values."]
pub type celix_array_list_entry_t = celix_array_list_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_array_list {
    _unused: [u8; 0],
}
#[doc = " @brief A celix array list, which can store a list of undefined elements."]
pub type celix_array_list_t = celix_array_list;
#[doc = " @brief Equals function for array list entries, can be provided when creating a array list."]
pub type celix_arrayList_equals_fp = ::std::option::Option<
    unsafe extern "C" fn(arg1: celix_array_list_entry_t, arg2: celix_array_list_entry_t) -> bool,
>;
#[doc = " @brief Compare function for array list entries, which can be used to sort a array list."]
pub type celix_array_list_compare_entries_fp = ::std::option::Option<
    unsafe extern "C" fn(
        a: celix_array_list_entry_t,
        b: celix_array_list_entry_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Copy function for array list entries, which can be used to copy a array list entry.\n @return CELIX_SUCCESS if the entry is copied, CELIX_ENOMEM if the entry could not be copied."]
pub type celix_array_list_copy_entry_fp = ::std::option::Option<
    unsafe extern "C" fn(
        src: celix_array_list_entry_t,
        dst: *mut celix_array_list_entry_t,
    ) -> celix_status_t,
>;
extern "C" {
    #[doc = " @brief Creates a new empty array list with an undefined element type.\n @deprecated Use celix_arrayList_createWithOptions or celix_arrayList_create<Type>Array instead.\n\n The remove, equals and compare callback will be NULL.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_create() -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Creates a new empty array list with a pointer element type where the array list is not the owner of the\n pointers.\n\n The remove, equals, compare and copy callback will be NULL.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createPointerArray() -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Creates a new empty array list with a string element type where the array list is the owner of the strings.\n\n The remove callback will be configured to free the string, the equals and compare callback will be configured for\n string comparison and the copy callback will be a callback to uses celix_utils_strdup.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createStringArray() -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Creates a new empty array list with a long integer element type.\n\n The remove callback will be configured to NULL, the equals and compare callback will be configured for\n integer comparison and the copy callback will be configured to NULL.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createLongArray() -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Creates a new empty array list with a double element type.\n\n The remove callback will be configured to NULL, the equals and compare callback will be configured for\n double comparison and the copy callback will be configured to NULL.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createDoubleArray() -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Creates a new empty array list with a boolean element type.\n\n The remove callback will be configured to NULL, the equals and compare callback will be configured for\n boolean comparison and the copy callback will be configured to NULL.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createBoolArray() -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Creates a new empty array list with a celix_version_t* element type.\n\n The remove callback will be configured to free a celix version, the equals and compare callback will be configured\n for celix version comparison and the copy callback will a callback that uses celix_version_copy.\n\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createVersionArray() -> *mut celix_array_list_t;
}
#[doc = " Additional create options when creating a array list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_array_list_create_options {
    #[doc = " The element type of the array list. Default is CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED."]
    pub elementType: celix_array_list_element_type_t,
    #[doc = " A simple removed callback, which if provided will be called if a entry is removed\n from the array list. The removed entry is provided as pointer.\n\n @note Assumes that the array list entries are pointer values.\n\n @note only simpleRemovedCallback or removedCallback should be configured, if both are configured,\n only the simpledRemoveCallback will be used.\n\n Default is NULL."]
    pub simpleRemovedCallback:
        ::std::option::Option<unsafe extern "C" fn(value: *mut ::std::os::raw::c_void)>,
    #[doc = " Optional callback data, which will be provided to the removedCallback callback.\n\n Default is NULL."]
    pub removedCallbackData: *mut ::std::os::raw::c_void,
    #[doc = " A removed callback, which if provided will be called if a entry is removed from the array list.\n The callback data pointer will be provided as first argument to the removed callback.\n\n @note only simpleRemovedCallback or removedCallback should be configured, if both are configured,\n only the simpledRemoveCallback will be used.\n\n Default is NULL."]
    pub removedCallback: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, entry: celix_array_list_entry_t),
    >,
    #[doc = " Equals callback used when trying to find a array list entry."]
    pub equalsCallback: celix_arrayList_equals_fp,
    #[doc = " Compare callback used when sorting the array list."]
    pub compareCallback: celix_array_list_compare_entries_fp,
    #[doc = " The copy callback used to copy a array list entry.\n If callback is NULL, a celix_arrayList_copy will result in a shallow copy."]
    pub copyCallback: celix_array_list_copy_entry_fp,
    #[doc = " Initial capacity of the array list. If 0, the default capacity will be used."]
    pub initialCapacity: usize,
}
#[test]
fn bindgen_test_layout_celix_array_list_create_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_array_list_create_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_array_list_create_options>(),
        64usize,
        concat!("Size of: ", stringify!(celix_array_list_create_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_array_list_create_options>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_array_list_create_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elementType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(elementType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).simpleRemovedCallback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(simpleRemovedCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removedCallbackData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(removedCallbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removedCallback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(removedCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equalsCallback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(equalsCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compareCallback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(compareCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(copyCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialCapacity) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_array_list_create_options),
            "::",
            stringify!(initialCapacity)
        )
    );
}
#[doc = " Additional create options when creating a array list."]
pub type celix_array_list_create_options_t = celix_array_list_create_options;
extern "C" {
    #[doc = " @brief Creates a new empty array list using using the provided array list create options.\n\n The callbacks in the options will override the default callbacks based on the provided element type.\n The default callbacks (e.g. the remove, equals, compare and copy callback) correspond to the\n celix_arrayList_create<Type>Array function.\n For example if the elementType is CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING, the default callbacks will be set to\n handle string values.\n\n @param opts The create options, only used during the creation of the array list.\n @return A new empty array list or NULL if the array list could not be created. If NULL is returned an error message\n is logged to celix_err."]
    pub fn celix_arrayList_createWithOptions(
        opts: *const celix_array_list_create_options_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Clears and then deallocated the array list.\n\n @note If a (simple) removed callback is configured, the callback will be called for every array list entry."]
    pub fn celix_arrayList_destroy(list: *mut celix_array_list_t);
}
pub type celix_array_list_t_autoptr = *mut celix_array_list_t;
extern "C" {
    #[doc = " @brief Return the element type of the array list."]
    pub fn celix_arrayList_getElementType(
        list: *const celix_array_list_t,
    ) -> celix_array_list_element_type_t;
}
extern "C" {
    #[doc = " @brief Returns the size of the array list."]
    pub fn celix_arrayList_size(list: *const celix_array_list_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the value for the provided index.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_POINTER or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the pointer value for the index. Returns NULL if index is out of bound."]
    pub fn celix_arrayList_get(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Returns the value for the provided index.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING\n or CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the string value for the index. Returns NULL if index is out of bound."]
    pub fn celix_arrayList_getString(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the value for the provided index.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_LONG or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the long value for the index. Returns 0 if index is out of bound."]
    pub fn celix_arrayList_getLong(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Returns the value for the provided index.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_DOUBLE or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the double value for the index. Returns 0 if index is out of bound."]
    pub fn celix_arrayList_getDouble(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Returns the value for the provided index.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_BOOL or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the bool value for the index. Returns false if index is out of bound."]
    pub fn celix_arrayList_getBool(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the value for the provided index.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION,\n or CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the version value for the index. Returns NULL if index is out of bound."]
    pub fn celix_arrayList_getVersion(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> *const celix_version_t;
}
extern "C" {
    #[doc = " @brief Returns the entry for the provided index.\n\n @param list The array list.\n @param index The entry index to return.\n @return Returns the entry for the index. Returns NULL if index is out of bound."]
    pub fn celix_arrayList_getEntry(
        list: *const celix_array_list_t,
        index: ::std::os::raw::c_int,
    ) -> celix_array_list_entry_t;
}
extern "C" {
    #[doc = " @brief add pointer entry to the back of the array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_POINTER or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The pointer value to add to the array list. Cannot be NULL.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory."]
    pub fn celix_arrayList_add(
        list: *mut celix_array_list_t,
        value: *mut ::std::os::raw::c_void,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Add a string entry to the back of the array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING\n or CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n If the array list element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING, the string will be copied, but\n if the array list element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED,\n the string will be added as reference (as-is).\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The string value to add to the array list. Cannot be NULL.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory."]
    pub fn celix_arrayList_addString(
        list: *mut celix_array_list_t,
        value: *const ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Add a string entry to the back of a string array list.\n\n The string will not be copied and the array list will take ownership of the string.\n\n Can only be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The string value to add to the array list. Cannot be NULL.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory. If an error is returned\n the provided value is not added to the array list, but the value will be freed using free."]
    pub fn celix_arrayList_assignString(
        list: *mut celix_array_list_t,
        value: *mut ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief add pointer entry to the back of the array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_LONG or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The long value to add to the array list.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory."]
    pub fn celix_arrayList_addLong(
        list: *mut celix_array_list_t,
        value: ::std::os::raw::c_long,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief add pointer entry to the back of the array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_DOUBLE or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The double value to add to the array list.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory."]
    pub fn celix_arrayList_addDouble(list: *mut celix_array_list_t, value: f64) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief add pointer entry to the back of the array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_BOOL or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The bool value to add to the array list.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory."]
    pub fn celix_arrayList_addBool(list: *mut celix_array_list_t, value: bool) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Add a version entry to the back of the version array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION,\n or CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n If the array list element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION, the version will be copied, but\n if the array list element type is CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED,\n the string will be added as reference (as-is).\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The version value to add to the array list. Cannot be NULL.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory."]
    pub fn celix_arrayList_addVersion(
        list: *mut celix_array_list_t,
        value: *const celix_version_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Add a version entry to the back of a version array list.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION.\n The version will not be copied and the array list will take ownership of the version.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param list The array list.\n @param value The version value to add to the array list. Cannot be NULL.\n @return CELIX_SUCCESS if the value is added, CELIX_ENOMEM if the array list is out of memory. If an error is\n returned, the provided value is not added to the array list, but the value will be freed using celix_version_destroy."]
    pub fn celix_arrayList_assignVersion(
        list: *mut celix_array_list_t,
        value: *mut celix_version_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Returns the index of the provided entry, if found.\n\n The equals callback function provided when the array list was created will be used\n to determine if a array list entry equals the provided entry.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done.\n\n @param list The array list.\n @param entry The entry to find.\n @return The index of the entry or -1 if the entry is not found."]
    pub fn celix_arrayList_indexOf(
        list: *mut celix_array_list_t,
        entry: celix_array_list_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Removes an entry at the provided index.\n If the provided index < 0 or out of bound, nothing will be removed."]
    pub fn celix_arrayList_removeAt(list: *mut celix_array_list_t, index: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Clear all entries in the array list.\n\n @note If a (simple) removed callback is configured, the callback will be called for every array list entry."]
    pub fn celix_arrayList_clear(list: *mut celix_array_list_t);
}
extern "C" {
    #[doc = " @brief Remove the first entry from array list which matches the provided value.\n\n The provided entry is expected to be cleared using memset, before it gets assigned a value.\n If there is no equals provided, the entry will not be removed.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_removeEntry(
        list: *mut celix_array_list_t,
        entry: celix_array_list_entry_t,
    );
}
extern "C" {
    #[doc = " @brief Remove the first pointer entry from array list which matches the provided value.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_POINTER or\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_remove(
        list: *mut celix_array_list_t,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Remove the first string entry from array list which matches the provided value.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING and\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_removeString(
        list: *mut celix_array_list_t,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Remove the first long entry from array list which matches the provided value.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_LONG and\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_removeLong(list: *mut celix_array_list_t, value: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " @brief Remove the first double entry from array list which matches the provided value.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_DOUBLE and\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_removeDouble(list: *mut celix_array_list_t, value: f64);
}
extern "C" {
    #[doc = " @brief Remove the first bool entry from array list which matches the provided value.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_BOOL and\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_removeBool(list: *mut celix_array_list_t, value: bool);
}
extern "C" {
    #[doc = " @brief Remove the first version entry from array list which matches the provided value.\n\n Can be used for array list with element type CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION and\n CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED.\n\n The equals callback provided when the array list was created will be used to find the entry.\n If there was no equals callback provided a direct memory compare will be done."]
    pub fn celix_arrayList_removeVersion(
        list: *mut celix_array_list_t,
        value: *const celix_version_t,
    );
}
extern "C" {
    #[doc = " @brief Sort the array list using the provided sort function."]
    pub fn celix_arrayList_sortEntries(
        list: *mut celix_array_list_t,
        compare: celix_array_list_compare_entries_fp,
    );
}
extern "C" {
    #[doc = " @brief Sort the array list using the array list configured compare function.\n Note that undefined the array list compare function can be NULL and in that case the array list will not be sorted."]
    pub fn celix_arrayList_sort(list: *mut celix_array_list_t);
}
extern "C" {
    #[doc = " @brief Check if the array list are equal.\n\n Equal is defined as:\n - The array list have the same size\n - The array list have the same element type\n - The array list have the same equals callback\n - The array list have the same values at the same index\n\n Note that the remove, compare and copy callbacks are ignored.\n\n If both array list are NULL, they are considered equal.\n\n @param listA The first array list.\n @param listB The second array list.\n @return true if the array list are equal, false otherwise."]
    pub fn celix_arrayList_equals(
        listA: *const celix_array_list_t,
        listB: *const celix_array_list_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @Brief Copy the array list to a new array list.\n\n The new array list will have the same element type and the same callbacks as the original array list.\n For copying the array list entries the copy callback will be used, if the capy callback is NULL a shallow copy will\n be done.\n\n If a NULL is returned and the original array list is not NULL, a error message is logged to celix_err.\n\n @param[in] list The array list to copy.\n @return A new array list with the same element type and values as the original array list or NULL if the original\n array list is NULL or out of memory."]
    pub fn celix_arrayList_copy(list: *const celix_array_list_t) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Returns the element type as a string.\n The returned string is owned by the celix_arrayList library and should not be freed.\n @param type The element type.\n @return The element type as a string. Returns \"Undefined\" if the element type is not recognized."]
    pub fn celix_arrayList_elementTypeToString(
        type_: celix_array_list_element_type_t,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = "< Property value is not set."]
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_UNSET:
    celix_properties_value_type = 0;
#[doc = "< Property value is a string."]
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_STRING:
    celix_properties_value_type = 1;
#[doc = "< Property value is a long integer."]
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_LONG:
    celix_properties_value_type = 2;
#[doc = "< Property value is a double."]
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_DOUBLE:
    celix_properties_value_type = 3;
#[doc = "< Property value is a boolean."]
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_BOOL:
    celix_properties_value_type = 4;
#[doc = "< Property value is a Celix version."]
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_VERSION:
    celix_properties_value_type = 5;
pub const celix_properties_value_type_CELIX_PROPERTIES_VALUE_TYPE_ARRAY_LIST:
    celix_properties_value_type = 6;
#[doc = " @brief Enum representing the possible types of a property value."]
pub type celix_properties_value_type = ::std::os::raw::c_uint;
#[doc = " @brief Enum representing the possible types of a property value."]
pub use self::celix_properties_value_type as celix_properties_value_type_e;
#[doc = " @brief A structure representing a single value entry in a property set."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct celix_properties_entry {
    #[doc = "< The string value or string representation of a non-string\ntyped value."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = "< The type of the value of the entry"]
    pub valueType: celix_properties_value_type_e,
    #[doc = "< The typed values of the entry. Only valid if valueType\nis not CELIX_PROPERTIES_VALUE_TYPE_UNSET and only the matching\nvalue types should be used. E.g typed.boolValue if valueType is\nCELIX_PROPERTIES_VALUE_TYPE_BOOL."]
    pub typed: celix_properties_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union celix_properties_entry__bindgen_ty_1 {
    #[doc = "< The string value of the entry."]
    pub strValue: *const ::std::os::raw::c_char,
    #[doc = "< The long integer value of the entry."]
    pub longValue: ::std::os::raw::c_long,
    #[doc = "< The double-precision floating point value of the entry."]
    pub doubleValue: f64,
    #[doc = "< The boolean value of the entry."]
    pub boolValue: bool,
    #[doc = "< The Celix version value of the entry."]
    pub versionValue: *const celix_version_t,
    #[doc = "< The array list of longs, doubles, bools, strings or versions value of the entry."]
    pub arrayValue: *const celix_array_list_t,
}
#[test]
fn bindgen_test_layout_celix_properties_entry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<celix_properties_entry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_properties_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(celix_properties_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<celix_properties_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(celix_properties_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry__bindgen_ty_1),
            "::",
            stringify!(strValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).longValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry__bindgen_ty_1),
            "::",
            stringify!(longValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubleValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry__bindgen_ty_1),
            "::",
            stringify!(doubleValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry__bindgen_ty_1),
            "::",
            stringify!(boolValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry__bindgen_ty_1),
            "::",
            stringify!(versionValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry__bindgen_ty_1),
            "::",
            stringify!(arrayValue)
        )
    );
}
#[test]
fn bindgen_test_layout_celix_properties_entry() {
    const UNINIT: ::std::mem::MaybeUninit<celix_properties_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_properties_entry>(),
        24usize,
        concat!("Size of: ", stringify!(celix_properties_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_properties_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_properties_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry),
            "::",
            stringify!(valueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_entry),
            "::",
            stringify!(typed)
        )
    );
}
#[doc = " @brief A structure representing a single value entry in a property set."]
pub type celix_properties_entry_t = celix_properties_entry;
#[doc = " @brief Represents an iterator for iterating over the entries in a celix_properties_t object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct celix_properties_iterator {
    #[doc = " @brief The current key."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " @brief The current value entry."]
    pub entry: celix_properties_entry_t,
    #[doc = " @brief Private data used to implement the iterator."]
    pub _data: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout_celix_properties_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<celix_properties_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_properties_iterator>(),
        88usize,
        concat!("Size of: ", stringify!(celix_properties_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_properties_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_properties_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_iterator),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_iterator),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_properties_iterator),
            "::",
            stringify!(_data)
        )
    );
}
#[doc = " @brief Represents an iterator for iterating over the entries in a celix_properties_t object."]
pub type celix_properties_iterator_t = celix_properties_iterator;
extern "C" {
    #[doc = " @brief Create a new empty property set.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @return A new empty property set."]
    pub fn celix_properties_create() -> *mut celix_properties_t;
}
extern "C" {
    #[doc = " @brief Destroy a property set, freeing all associated resources.\n\n @param[in] properties The property set to destroy. If properties is NULL, this function will do nothing."]
    pub fn celix_properties_destroy(properties: *mut celix_properties_t);
}
pub type celix_properties_t_autoptr = *mut celix_properties_t;
extern "C" {
    #[doc = " @brief Load properties from a file.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] filename The name of the file to load properties from.\n @return A property set containing the properties from the file.\n @retval NULL If an error occurred (e.g. file not found)."]
    pub fn celix_properties_load(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut celix_properties_t;
}
extern "C" {
    #[doc = " @brief Load properties from a stream.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in,out] stream The stream to load properties from.\n @return A property set containing the properties from the stream.\n @retval NULL If an error occurred (e.g. invalid format)."]
    pub fn celix_properties_loadWithStream(stream: *mut FILE) -> *mut celix_properties_t;
}
extern "C" {
    #[doc = " @brief Load properties from a string.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] input The string to load properties from.\n @return A property set containing the properties from the string.\n @retval NULL If an error occurred (e.g. invalid format)."]
    pub fn celix_properties_loadFromString(
        input: *const ::std::os::raw::c_char,
    ) -> *mut celix_properties_t;
}
extern "C" {
    #[doc = " @brief Store properties to a file.\n\n @note Properties values are always stored as string values, regardless of their actual underlining types.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to store.\n @param[in] file The name of the file to store the properties to.\n @param[in] header An optional - single line - header to write to the file before the properties.\n                   Will be prefix with a '#' character.\n @return CELIX_SUCCESS if the operation was successful, CELIX_FILE_IO_EXCEPTION if there was an error writing to the\n         file."]
    pub fn celix_properties_store(
        properties: *mut celix_properties_t,
        file: *const ::std::os::raw::c_char,
        header: *const ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the entry for a given key in a property set.\n\n @param[in] properties The property set to search.\n @param[in] key The key to search for.\n @return The entry for the given key, or a NULL if the key is not found."]
    pub fn celix_properties_getEntry(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_properties_entry_t;
}
extern "C" {
    #[doc = " @brief Get the string value or string representation of a property.\n\n @note identical to celix_properties_getAsString\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set.\n @return The value of the property, or the default value if the property is not set."]
    pub fn celix_properties_get(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the type of a property value.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get the type of.\n @return The type of the property value, or CELIX_PROPERTIES_VALUE_TYPE_UNSET if the property is not set."]
    pub fn celix_properties_getType(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> celix_properties_value_type_e;
}
extern "C" {
    #[doc = " @brief Check if the properties set has the provided key.\n @param[in] properties The property set to search.\n @param[in] key The key to search for.\n @return True if the property set has the provided key, false otherwise."]
    pub fn celix_properties_hasKey(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the string value of a property.\n\n @note Identical to celix_properties_setString.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_STRING.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] value The value to set the property to.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_set(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Set the value of a property without copying the value string.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_STRING.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set. This callee will take ownership of the key, so the key must not be\n                used after calling this function. The key should be deallocated with free.\n @param[in] value The value to set the property to. This callee will take ownership of the value, so the value must\n                  not be used after calling this function. The value should be deallocated with free.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key or value is NULL.\n         When an error status is returned, the key and value will be freed by this function."]
    pub fn celix_properties_assign(
        properties: *mut celix_properties_t,
        key: *mut ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the value of a property, if the property is set and the underlying type is a string.\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return The value of the property, or NULL if the property is not set or the value is not of the requested type."]
    pub fn celix_properties_getString(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the string value or string representation of a property.\n\n @note identical to celix_properties_get\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set.\n @return The value of the property, or the default value if the property is not set."]
    pub fn celix_properties_getAsString(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Set the string value of a property.\n\n @note Identical to celix_properties_set.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_STRING.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] value The value to set the property to.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_setString(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Assign the value of a property with the provided string pointer.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_STRING.\n\n This function take ownership of the provided string.\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] value The value to assign. The function take ownership of the provided version. Cannot be NULL.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL. When an error status is returned,\n         the string will be free by this function."]
    pub fn celix_properties_assignString(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the value of a property, if the property is set and the underlying type is a long.\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set or the value is not a long.\n @return The value of the property, or the default value if the property is not set or the value is not of the\n requested type."]
    pub fn celix_properties_getLong(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the value of a property as a long integer.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set, the value is not a long integer,\n                     or if the value cannot be converted to a long integer.\n @return The value of the property as a long integer, or the default value if the property is not set,\n         the value is not a long integer, or if the value cannot be converted to a long integer.\n         If the value is a string, it will be converted to a long integer if possible."]
    pub fn celix_properties_getAsLong(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Set the value of a property to a long integer.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_LONG.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] value The long value to set the property to.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_setLong(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the value of a property, if the property is set and the underlying type is a boolean.\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set or the value is not a boolean.\n @return The value of the property, or the default value if the property is not set or the value is not of the\n requested type."]
    pub fn celix_properties_getBool(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the value of a property as a boolean.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set, the value is not a boolean, or if the value\n                     cannot be converted to a boolean.\n @return The value of the property as a boolean, or the default value if the property is not set, the value is not a\n         boolean, or if the value cannot be converted to a boolean. If the value is a string, it will be converted\n         to a boolean if possible."]
    pub fn celix_properties_getAsBool(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the value of a property to a boolean.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_BOOL.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] val The boolean value to set the property to.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_setBool(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        val: bool,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Set the value of a property to a double.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_DOUBLE.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] val The double value to set the property to.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_setDouble(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        val: f64,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the value of a property, if the property is set and the underlying type is a double.\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set or the value is not a double.\n @return The value of the property, or the default value if the property is not set or the value is not of the\n requested type."]
    pub fn celix_properties_getDouble(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Get the value of a property as a double.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set, the value is not a double,\n                     or if the value cannot be converted to a double.\n @return The value of the property as a double, or the default value if the property is not set, the value is not\n         a double, or if the value cannot be converted to a double. If the value is a string, it will be converted\n         to a double if possible."]
    pub fn celix_properties_getAsDouble(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Set the value of a property as a Celix version.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_VERSION.\n\n This function will make a copy of the provided celix_version_t object and store it in the property set.\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] version The value to set. The function will make a copy of this object and store it in the property set.\n Cannot be NULL.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_setVersion(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        version: *const celix_version_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Assign the value of a property with the provided Celix version pointer.\n\n The set property type will be CELIX_PROPERTIES_VALUE_TYPE_VERSION.\n\n This function will store a reference to the provided celix_version_t object in the property set and takes\n ownership of the provided version.\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] version The value to assign. The function will store a reference to this object in the property set and\n                    takes ownership of the provided version. Cannot be NULL.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL. When an error status is returned,\n         the version will be destroy with celix_version_destroy by this function."]
    pub fn celix_properties_assignVersion(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        version: *mut celix_version_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the Celix version value of a property without copying.\n\n This function provides a non-owning, read-only access to a Celix version contained in the properties.\n It returns a const pointer to the Celix version value associated with the specified key.\n This function does not perform any conversion from a string property value to a Celix version.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the Celix version if it is present and valid, or NULL if the\n property is not set or the value is not a valid Celix version. The returned pointer should not be modified or freed."]
    pub fn celix_properties_getVersion(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_version_t;
}
extern "C" {
    #[doc = " @brief Get a value of a property as a copied Celix version.\n\n If the property value is a Celix version, a copy of the found version will be returned.\n If the property value is a string, this function will attempt to convert it to a new Celix version.\n If the property is not set or is not a valid Celix version string, a copy of the provided defaultValue is returned.\n\n @note The caller is responsible for deallocating the memory of the returned version.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The value to return if the property is not set or if the value is not a Celix version.\n @param[out] version A copy of the found version, a new parsed version, or a copy of the default value if the\n                 property is not set, its value is not an version or its value cannot be converted to an version.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to create the\n        version. Note if the key is not found, the return status is still CELIX_SUCCESS."]
    pub fn celix_properties_getAsVersion(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const celix_version_t,
        version: *mut *mut celix_version_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Set a pointer, long, double, bool, string or version array list array for a property value.\n\n The set property type cannot be CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED or CELIX_ARRAY_LIST_ELEMENT_TYPE_POINTER\n\n This function will make a copy of the provided celix_array_list_t object, using the celix_arrayList_copy function.\n\n If an error occurs, the error status is returned and a message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] values An array list of types values to set for the property. Cannot be NULL.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry,\n         and CELIX_ILLEGAL_ARGUMENT if the provided key or values is NULL or if the array list type is\n         valid."]
    pub fn celix_properties_setArrayList(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        values: *const celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Assign a pointer, long, double, bool, string or version array list array for a property value.\n\n The set property type cannot be CELIX_ARRAY_LIST_ELEMENT_TYPE_UNDEFINED or CELIX_ARRAY_LIST_ELEMENT_TYPE_POINTER\n\n This function stores a reference to the provided celix_array_list_t object in the property set and takes\n ownership of the array.\n If an error occurs, the error status is returned, the provided array is destroyed and a\n message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] values An array list of long values to assign to the property. Ownership of the array is transferred\n                   to the properties set. Cannot be NULL.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry,\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL, values is NULL or the array list type is\n         invalid. On error, the provided array list is destroyed."]
    pub fn celix_properties_assignArrayList(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        values: *mut celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the property value as an array without copying.\n\n This function provides a non-owning, read-only access to a array property value.\n It returns a const pointer to the array. If the property is not set or its value is not an array, NULL is returned.\n\n The returned array will have a element type of:\n  - CELIX_ARRAY_LIST_ELEMENT_TYPE_STRING\n  - CELIX_ARRAY_LIST_ELEMENT_TYPE_LONG\n  - CELIX_ARRAY_LIST_ELEMENT_TYPE_DOUBLE\n  - CELIX_ARRAY_LIST_ELEMENT_TYPE_BOOL\n  - CELIX_ARRAY_LIST_ELEMENT_TYPE_VERSION\n\n  Note that users should check the element type of the returned array list to determine the type of the elements.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the array list property value, or NULL if the property is not set or its value is not\n an array list. The returned pointer should not be modified or freed."]
    pub fn celix_properties_getArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Get a property value as an array of longs.\n\n This function retrieves the value of a property, interpreting it as an array of longs. If the underlying type of the\n property value is a long array, a copy of the array is returned. If the underlying type is a string, the string is\n converted to an array of longs if possible.\n If the property is not set, its value is not an array of longs or its value cannot be converted to a long array,\n the default value is returned as a copy.\n\n An celix err is logged if the default value is needed and not an array list with long values.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The default value to return if the property is not set or its value is not an array of longs.\n @param[out] list A copy of the found list, a new array list with long values or a copy of the default value if the\n                 property is not set, its value is not an array of longs or its value cannot be converted to an array\n                 of longs.\n @return CELIX_SUCCESS if the operation was successful. Note if the key is not found or the value cannot be converted\n to an array of longs, the return status is still CELIX_SUCCESS.\n @returnval CELIX_ENOMEM if there was not enough memory to create the array list.\n @returnval CELIX_ILLEGAL_ARGUMENT if the provided default value is not NULL and not an array list with long values.\n            In this case an error message is also logged to celix_err."]
    pub fn celix_properties_getAsLongArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const celix_array_list_t,
        list: *mut *mut celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the property value as an array of longs without copying.\n\n This function provides a non-owning, read-only access to an array of longs property value.\n It returns a const pointer to the array. If the property is not set or its value is not an array of longs,\n NULL is returned.\n\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the property value interpreted as an array of longs, or NULL if the property\n         is not set or its value is not an array of longs. The returned pointer should not be modified or freed."]
    pub fn celix_properties_getLongArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Get a property value as an array of doubles, making a copy of the array.\n\n This function retrieves the value of a property, interpreting it as an array of doubles. If the underlying type of\n the property value is a double array, a copy of the array is returned. If the underlying type is a string, the string\n is converted to an array of doubles if possible. If the property is not set, its value is not an array of doubles or\n its value cannot be converted to a double array, the default value is returned as a copy.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The default value to return if the property is not set or its value is not an array of\n doubles.\n @param[out] list A copy of the found list, a new array list with double values or a copy of the default value if the\n                 property is not set, its value is not an array doubles longs or its value cannot be converted to an\n array of doubles.\n @return CELIX_SUCCESS if the operation was successful. Note if the key is not found or the value cannot be converted\n to an array of doubles, the return status is still CELIX_SUCCESS.\n @returnval CELIX_ENOMEM if there was not enough memory to create the array list.\n @returnval CELIX_ILLEGAL_ARGUMENT if the provided default value is not NULL and not an array list with double values.\n            In this case an error message is also logged to celix_err."]
    pub fn celix_properties_getAsDoubleArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const celix_array_list_t,
        list: *mut *mut celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the property value as an array of doubles without copying.\n\n This function provides a non-owning, read-only access to an array of doubles property value.\n It returns a const pointer to the array. If the property is not set or its value is not an array of doubles,\n NULL is returned.\n\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the property value interpreted as an array of doubles, or NULL if the\n property is not set or its value is not an array of doubles. The returned pointer should not be modified or freed."]
    pub fn celix_properties_getDoubleArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Get a property value as an array of booleans, making a copy of the array.\n\n This function retrieves the value of a property, interpreting it as an array of booleans. If the underlying type of\n the property value is a boolean array, a copy of the array is returned. If the underlying type is a string, the\n string is converted to an array of booleans if possible. If the property is not set, its value is not an array of\n booleans or its value cannot be converted to a boolean array, the default value is returned as a copy.\n\n An celix err is logged if the default value is needed and not an array list with boolean values.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The default value to return if the property is not set or its value is not an array of\n booleans.\n @param[out] list A copy of the found list, a new array list with boolean values or a copy of the default value if the\n                 property is not set, its value is not an array of booleans or its value cannot be converted to an\n array of booleans.\n @return CELIX_SUCCESS if the operation was successful. Note if the key is not found or the value cannot be converted\n to an array of booleans, the return status is still CELIX_SUCCESS.\n @returnval CELIX_ENOMEM if there was not enough memory to create the array list.\n @returnval CELIX_ILLEGAL_ARGUMENT if the provided default value is not NULL and not an array list with bool values.\n            In this case an error message is also logged to celix_err."]
    pub fn celix_properties_getAsBoolArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const celix_array_list_t,
        list: *mut *mut celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the property value as an array of booleans without copying.\n\n This function provides a non-owning, read-only access to a array of booleans property value.\n It returns a const pointer to the array. If the property is not set or its value is not an array of booleans,\n NULL is returned.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the property value interpreted as an array of booleans, or NULL if the\n property is not set or its value is not an array of booleans. The returned pointer should not be modified or freed."]
    pub fn celix_properties_getBoolArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Get a property value as an array of strings, making a copy of the array.\n\n This function retrieves the value of a property, interpreting it as an array of strings. If the underlying type of\n the property value is a string array, a copy of the array is returned. If the underlying type is a string, the string\n is converted to an array of strings if possible. If the property is not set, its value is not an array of strings or\n  its value cannot be converted to a string array, the default value is returned as a copy.\n\n The returned array list is configured with a remove callback so that the destruction of the array list will also\n free the strings in the array list.\n\n An celix err is logged if the default value is needed and not an array list with string values.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The default value to return if the property is not set or its value is not an array of\n strings.\n @param[out] list A copy of the found list, a new array list with string values or a copy of the default value if the\n                 property is not set, its value is not an array of strings or its value cannot be converted to an\n                 array of strings.\n @return CELIX_SUCCESS if the operation was successful. Note if the key is not found or the value cannot be converted\n to an array of strings, the return status is still CELIX_SUCCESS.\n @returnval CELIX_ENOMEM if there was not enough memory to create the array list.\n @returnval CELIX_ILLEGAL_ARGUMENT if the provided default value is not NULL and not an array list with string values.\n            In this case an error message is also logged to celix_err."]
    pub fn celix_properties_getAsStringArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const celix_array_list_t,
        list: *mut *mut celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the property value as an array of strings without copying.\n\n This function provides a non-owning, read-only access to an array of string property value.\n It returns a const pointer to the array. If the property is not set or its value is not an array of strings,\n NULL is returned.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the property value interpreted as an array of strings, or NULL if the\n property is not set or its value is not an array of strings. The returned pointer should not be modified or freed."]
    pub fn celix_properties_getStringArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Get a property value as an array of celix_version_t entries, making a copy of the array.\n\n\n This function retrieves the value of a property, interpreting it as an array of celix_version_t* entries. If the\n underlying type of the property value is a celix_version_t* array, a copy of the array is returned. If the underlying\n type is a string, the string is converted to an array of celix_version_t* if possible. If the property is not set,\n its value is not an array of celix_version_t* entries or its value cannot be converted to a celix_version_t* array,\n the default value is returned as a copy.\n\n The returned array list is configured with a remove callback so that the destruction of the array list will also\n free the celix_version_t entries in the array list.\n\n An celix err is logged if the default value is needed and not an array list with celix_version_t values.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @param[in] defaultValue The default value to return if the property is not set or its value is not an array of\n celix_version_t entries.\n @param[out] list A copy of the found list, a new array list with celix_version_t values or a copy of the default\n value if the property is not set, its value is not an array of celix_version_t entries or its value cannot be\n converted to an array of celix_version_t entries.\n @return CELIX_SUCCESS if the operation was successful. Note if the key is not found or the value cannot be converted\n to an array of celix_version_t, the return status is still CELIX_SUCCESS.\n @returnval CELIX_ENOMEM if there was not enough memory to create the array list.\n @returnval CELIX_ILLEGAL_ARGUMENT if the provided default value is not NULL and not an array list with\n celix_version_t values. In this case an error message is also logged to celix_err."]
    pub fn celix_properties_getAsVersionArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
        defaultValue: *const celix_array_list_t,
        list: *mut *mut celix_array_list_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Get the property value as an array of celix_version_t entries without copying.\n\n This function provides a non-owning, read-only access to an array of celix_version_t property value.\n entries. It returns a const pointer to the array. If the property is not set or its value is not an array of\n celix_version_t entries, NULL is returned.\n\n @param[in] properties The property set to search.\n @param[in] key The key of the property to get.\n @return A const pointer to the property value interpreted as an array of celix_version_t entries, or NULL if the\n property is not set or its value is not an array of celix_version_t entries. The returned pointer should\n not be modified or freed."]
    pub fn celix_properties_getVersionArrayList(
        properties: *const celix_properties_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Set the value of a property based on the provided property entry, maintaining underlying type.\n\n The typed entry value will be copied, which means that this function will use the entry.typed.strValue,\n entry.typed.longValue, entry.typed.doubleValue, entry.typed.boolValue or entry.typed.versionValue depending on\n the entry.valueType. The entry.strValue will be ignored.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to set.\n @param[in] entry The entry to set the property to. The typed entry will be copied, so it can be freed after calling\n                  this function.\n @return CELIX_SUCCESS if the operation was successful, CELIX_ENOMEM if there was not enough memory to set the entry\n         and CELIX_ILLEGAL_ARGUMENT if the provided key is NULL."]
    pub fn celix_properties_setEntry(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
        entry: *const celix_properties_entry_t,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Unset a property, removing it from the property set.\n\n @param[in] properties The property set to modify.\n @param[in] key The key of the property to unset."]
    pub fn celix_properties_unset(
        properties: *mut celix_properties_t,
        key: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Make a copy of a properties set.\n\n If the return status is an error, an error message is logged to celix_err.\n\n @param[in] properties The property set to copy.\n @return A copy of the given property set."]
    pub fn celix_properties_copy(properties: *const celix_properties_t) -> *mut celix_properties_t;
}
extern "C" {
    #[doc = " @brief Get the number of properties in a property set.\n\n @param[in] properties The property set to get the size of.\n @return The number of properties in the property set."]
    pub fn celix_properties_size(properties: *const celix_properties_t) -> usize;
}
extern "C" {
    #[doc = " @brief Check whether the provided property sets are equal.\n\n Equals means that both property sets have the same number of properties and that all properties in the first set\n are also present in the second set and have the same value.\n\n @param[in] props1 The first property set to compare.\n @param[in] props2 The second property set to compare.\n @return true if the property sets are equal, false otherwise."]
    pub fn celix_properties_equals(
        props1: *const celix_properties_t,
        props2: *const celix_properties_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Construct an iterator pointing to the first entry in the properties object.\n\n @param[in] properties The properties object to iterate over.\n @return The iterator pointing to the first entry in the properties object."]
    pub fn celix_properties_begin(
        properties: *const celix_properties_t,
    ) -> celix_properties_iterator_t;
}
extern "C" {
    #[doc = " @brief Construct an iterator pointing to the past-the-end entry in the properties object.\n\n This iterator is used to mark the end of the properties object and is not associated with any element in the\n properties object.\n\n @param[in] properties The properties object to iterate over.\n @return The iterator pointing to the past-the-end entry in the properties object."]
    pub fn celix_properties_end(
        properties: *const celix_properties_t,
    ) -> celix_properties_iterator_t;
}
extern "C" {
    #[doc = " @brief Advance the iterator to the next entry.\n\n @param[in, out] iter The iterator."]
    pub fn celix_propertiesIterator_next(iter: *mut celix_properties_iterator_t);
}
extern "C" {
    #[doc = " @brief Determine whether the iterator is pointing to an end position.\n\n An iterator is at an end position if it has no more entries to visit.\n\n @param[in] iter The iterator.\n @return true if the iterator is at an end position, false otherwise."]
    pub fn celix_propertiesIterator_isEnd(iter: *const celix_properties_iterator_t) -> bool;
}
extern "C" {
    #[doc = " @brief Determine whether two iterators are equal.\n\n @param[in] a The first iterator to compare.\n @param[in] b The second iterator to compare.\n @return true if the iterators are equal, false otherwise."]
    pub fn celix_propertiesIterator_equals(
        a: *const celix_properties_iterator_t,
        b: *const celix_properties_iterator_t,
    ) -> bool;
}
#[doc = " @brief The Apache Celix filter type."]
pub type celix_filter_t = celix_filter_struct;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_EQUAL: celix_filter_operand_enum = 0;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_APPROX: celix_filter_operand_enum = 1;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_GREATER: celix_filter_operand_enum = 2;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_GREATEREQUAL: celix_filter_operand_enum =
    3;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_LESS: celix_filter_operand_enum = 4;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_LESSEQUAL: celix_filter_operand_enum = 5;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_PRESENT: celix_filter_operand_enum = 6;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_SUBSTRING: celix_filter_operand_enum = 7;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_AND: celix_filter_operand_enum = 8;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_OR: celix_filter_operand_enum = 9;
pub const celix_filter_operand_enum_CELIX_FILTER_OPERAND_NOT: celix_filter_operand_enum = 10;
#[doc = " @brief Enumeration of the filter operands."]
pub type celix_filter_operand_enum = ::std::os::raw::c_uint;
#[doc = " @brief Enumeration of the filter operands."]
pub use self::celix_filter_operand_enum as celix_filter_operand_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_filter_internal {
    _unused: [u8; 0],
}
#[doc = " @brief Internal opaque struct for internal use only."]
pub type celix_filter_internal_t = celix_filter_internal;
#[doc = " @brief The Apache Celix filter struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_filter_struct {
    #[doc = "< The filter operand."]
    pub operand: celix_filter_operand_t,
    #[doc = "< The filter attribute; NULL for operands `AND`, `OR` or `NOT`."]
    pub attribute: *const ::std::os::raw::c_char,
    #[doc = "< The filter value; NULL for operands `AND`, `OR` or `NOT`."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = "< The filter string representation."]
    pub filterStr: *const ::std::os::raw::c_char,
    #[doc = "< The filter children; only valid if the operand is not `AND`, `OR` or `NOT` else\nthe value is NULL."]
    pub children: *mut celix_array_list_t,
    #[doc = "< Internal use only."]
    pub internal: *mut celix_filter_internal_t,
}
#[test]
fn bindgen_test_layout_celix_filter_struct() {
    const UNINIT: ::std::mem::MaybeUninit<celix_filter_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_filter_struct>(),
        48usize,
        concat!("Size of: ", stringify!(celix_filter_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_filter_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_filter_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_filter_struct),
            "::",
            stringify!(operand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_filter_struct),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_filter_struct),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filterStr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_filter_struct),
            "::",
            stringify!(filterStr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_filter_struct),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_filter_struct),
            "::",
            stringify!(internal)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a filter based on the provided filter string.\n\n If the return status is NULL, an error message is logged to celix_err.\n\n @param filterStr The filter string. If NULL or \"\" a match-all \"(|)\" filter is created.\n @return The created filter or NULL if the filter string is invalid."]
    pub fn celix_filter_create(filterStr: *const ::std::os::raw::c_char) -> *mut celix_filter_t;
}
extern "C" {
    #[doc = " @brief Destroy the provided filter. Ignores NULL values."]
    pub fn celix_filter_destroy(filter: *mut celix_filter_t);
}
pub type celix_filter_t_autoptr = *mut celix_filter_t;
extern "C" {
    #[doc = " @brief Check whether the provided filter matches the provided properties.\n @param[in] filter The filter.\n @param[in] props The properties.\n @return True if the filter matches the properties, false otherwise. If filter is NULL always returns true and\n         if props is NULL, the result is the same as if an empty properties set was provided."]
    pub fn celix_filter_match(
        filter: *const celix_filter_t,
        props: *const celix_properties_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check whether the 2 filters are equal.\n\n Note that the equals is done based on the parsed filter string and not on the provided filter strings.\n So the filters parsed from the strings \"(key=value)\" and \" (key=value)\" are equal.\n\n @param[in] filter1 The first filter.\n @param[in] filter2 The second filter.\n @return True if the filters are equal, false otherwise."]
    pub fn celix_filter_equals(
        filter1: *const celix_filter_t,
        filter2: *const celix_filter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the filter string representation.\n\n @param[in] filter The filter.\n @return The filter string representation. The returned string is owned by the filter, must not be freed and is only\n         valid as long as the filter is valid."]
    pub fn celix_filter_getFilterString(
        filter: *const celix_filter_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Find the first filter attribute value matching the provided attribute name.\n\n Examples:\n  - filter arg: \"(key=value)\", attribute arg: \"key\" -> \"value\"\n  - filter arg: \"(key1=value1)(key2=value2)\", attribute arg: \"key2\" -> \"value2\"\n  - filter arg: \"(|(key1=value1)(key1=value2))\", attribute arg: \"key1\" -> \"value1\"\n\n @param[in] filter The filter.\n @param[in] attribute The attribute to find.\n @return The first found attribute or NULL if the attribute is not found. The returned string is owned by the filter,\n         must not be freed and is only valid as long as the filter is valid."]
    pub fn celix_filter_findAttribute(
        filter: *const celix_filter_t,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Determines if a filter has a mandatory 'equals' attribute with the provided attribute name.\n\n This function recursively examines a filter object to determine if it contains  an 'equals' attribute that matches\n the specified attribute name. The function takes into account the logical operators AND, OR, and NOT in the\n filter structure, and appropriately handles them to assess the presence and name of the attribute.\n\n Example:\n   using this function for attribute key \"key1\" on filter \"(key1=value1)\" yields true.\n   using this function for attribute key \"key1\" on filter \"(!(key1=value1))\" yields false.\n   using this function for attribute key \"key1\" on filter \"(key1>=value1)\" yields false.\n   using this function for attribute key \"key1\" on filter \"(|(key1=value1)(key2=value2))\" yields false.\n\n @param[in] filter The filter.\n @param[in] attribute The attribute to check.\n @return True if the filter indicates the mandatory presence of an attribute with a specific value for the provided\n         attribute key, false otherwise."]
    pub fn celix_filter_hasMandatoryEqualsValueAttribute(
        filter: *const celix_filter_t,
        attribute: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Determines if a filter mandates the absence of a specific attribute, irrespective of its value.\n\n This function recursively examines a filter object to determine if it contains a specification indicating the\n mandatory absence of the specified attribute. It takes into account logical operators AND, OR, and NOT in the filter\n structure, and appropriately handles them to assess the absence of the attribute.\n\n Examples:\n   using this function for attribute key \"key1\" on filter \"(!(key1=*))\" yields true.\n   using this function for attribute key \"key1\" on filter \"(key1=*)\" yields false.\n   using this function for attribute key \"key1\" on filter \"(key1=value)\" yields false.\n   using this function for attribute key \"key1\" on filter \"(|(!(key1=*))(key2=value2))\" yields false.\n\n @param[in] filter The filter to examine.\n @param[in] attribute The attribute to check for mandatory absence.\n @return True if the filter indicates the mandatory absence of the specified attribute, false otherwise."]
    pub fn celix_filter_hasMandatoryNegatedPresenceAttribute(
        filter: *const celix_filter_t,
        attribute: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_bundle_context {
    _unused: [u8; 0],
}
#[doc = " @brief The opaque type representing a bundle context."]
pub type celix_bundle_context_t = celix_bundle_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_framework {
    _unused: [u8; 0],
}
pub type celix_framework_t = celix_framework;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_bundle {
    _unused: [u8; 0],
}
pub type celix_bundle_t = celix_bundle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_dependency_manager {
    _unused: [u8; 0],
}
pub type celix_dependency_manager_t = celix_dependency_manager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_dm_component_struct {
    _unused: [u8; 0],
}
pub type celix_dm_component_t = celix_dm_component_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_dm_service_dependency {
    _unused: [u8; 0],
}
pub type celix_dm_service_dependency_t = celix_dm_service_dependency;
pub type dm_dependency_manager_t = celix_dependency_manager;
pub type dm_dependency_manager_pt = *mut celix_dependency_manager;
pub type dm_component_pt = *mut celix_dm_component_struct;
pub type dm_component_t = celix_dm_component_struct;
pub type dm_service_dependency_pt = *mut celix_dm_service_dependency;
pub type dm_service_dependency_t = celix_dm_service_dependency;
pub type bundle_context_pt = *mut celix_bundle_context;
pub type bundle_context_t = celix_bundle_context;
pub type framework_pt = *mut celix_framework;
pub type const_framework_pt = *const celix_framework;
pub type framework_t = celix_framework;
pub type bundle_pt = *mut celix_bundle;
pub type const_bundle_pt = *const celix_bundle;
pub type bundle_t = celix_bundle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bundleArchive {
    _unused: [u8; 0],
}
pub type bundle_archive_pt = *mut bundleArchive;
pub type bundle_archive_t = bundleArchive;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bundleRevision {
    _unused: [u8; 0],
}
pub type bundle_revision_pt = *mut bundleRevision;
pub type bundle_revision_t = bundleRevision;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service_factory {
    _unused: [u8; 0],
}
pub type service_factory_pt = *mut service_factory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serviceReference {
    _unused: [u8; 0],
}
pub type service_reference_pt = *mut serviceReference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serviceRegistration {
    _unused: [u8; 0],
}
pub type service_registration_t = serviceRegistration;
pub type service_registration_pt = *mut serviceRegistration;
pub const celix_bundleState_CELIX_BUNDLE_STATE_UNKNOWN: celix_bundleState = 0;
pub const celix_bundleState_CELIX_BUNDLE_STATE_UNINSTALLED: celix_bundleState = 1;
pub const celix_bundleState_CELIX_BUNDLE_STATE_INSTALLED: celix_bundleState = 2;
pub const celix_bundleState_CELIX_BUNDLE_STATE_RESOLVED: celix_bundleState = 4;
pub const celix_bundleState_CELIX_BUNDLE_STATE_STARTING: celix_bundleState = 8;
pub const celix_bundleState_CELIX_BUNDLE_STATE_STOPPING: celix_bundleState = 16;
pub const celix_bundleState_CELIX_BUNDLE_STATE_ACTIVE: celix_bundleState = 32;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_UNKNOWN: celix_bundleState = 0;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_UNINSTALLED: celix_bundleState = 1;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_INSTALLED: celix_bundleState = 2;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_RESOLVED: celix_bundleState = 4;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_STARTING: celix_bundleState = 8;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_STOPPING: celix_bundleState = 16;
pub const celix_bundleState_OSGI_FRAMEWORK_BUNDLE_ACTIVE: celix_bundleState = 32;
pub type celix_bundleState = ::std::os::raw::c_uint;
pub use self::celix_bundleState as bundle_state_e;
pub use self::celix_bundleState as celix_bundle_state_e;
extern "C" {
    pub fn celix_bundleState_getName(state: celix_bundle_state_e) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the bundle id.\n @param bnd The bundle\n @return The bundle id or < 0 if something went wrong."]
    pub fn celix_bundle_getId(bnd: *const celix_bundle_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Return the bundle state.\n @param bnd The bundle\n @return The bundle state or OSGI_FRAMEWORK_BUNDLE_UNKNOWN if something went wrong."]
    pub fn celix_bundle_getState(bnd: *const celix_bundle_t) -> celix_bundle_state_e;
}
extern "C" {
    #[doc = " Return a use-able entry path for the provided relative path to a bundle resource cache.\n\n For example if there is a resource entry in the bundle at path 'META-INF/descriptors/foo.descriptor` this call\n will return a relative path to the extracted location of the bundle resource, e.g.:\n .cache/bundle5/version0.0/META-INF/descriptors/foo.descriptor\n\n A provided path is always relative to the bundle root and can start with a \"/\".\n A provided path NULL, \"\", \".\" or \"/\" indicates the root of this bundle.\n\n The returned entry path should be treated as read-only, use celix_bundle_getDataFile to access the bundle's\n persistent storage.\n\n The caller is responsible for freeing the returned path entry.\n\n @param path The relative path to a bundle resource.\n @param bnd The bundle.\n @return A use-able path to the bundle resource entry or NULL if the entry is not found."]
    pub fn celix_bundle_getEntry(
        bnd: *const celix_bundle_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a use-able entry path for the provided relative path to a bundle persistent storage.\n\n For example if there is a resource entry in the bundle persistent storage at path 'resources/counters.txt` this call\n will return a relative path to entry in the bundle persistent storage.\n .cache/bundle5/storage/resources/counters.txt\n\n A provided path is always relative to the bundle persistent storage root and can start with a \"/\".\n A provided path NULL, \"\", \".\" or \"/\" indicates the root of this bundle cache store.\n\n The returned entry path should can be treated as read-write.\n\n The caller is responsible for freeing the returned path entry.\n\n @param path The relative path to a bundle persistent storage entry.\n @param bnd The bundle.\n @return A use-able path to the bundle resource entry or NULL if the entry is not found."]
    pub fn celix_bundle_getDataFile(
        bnd: *const celix_bundle_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get a manifest attribute value from the bundle manifest.\n @param bnd The bundle.\n @param attribute The attribute to get the value from.\n @return The attribute value or NULL if the attribute is not present in the bundle manifest.\n         The returned value is valid as long as the bundle is not uninstalled."]
    pub fn celix_bundle_getManifestValue(
        bnd: *const celix_bundle_t,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the group of the bundle. Groups are used to order bundles.\n Note the return value is valid as long as the bundle is installed."]
    pub fn celix_bundle_getGroup(bnd: *const celix_bundle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the symbolic name of the bundle.\n Note the return value is valid as long as the bundle is installed."]
    pub fn celix_bundle_getSymbolicName(
        bnd: *const celix_bundle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the name of the bundle.\n Note the return value is valid as long as the bundle is installed."]
    pub fn celix_bundle_getName(bnd: *const celix_bundle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the description of the bundle.\n Note the return value is valid as long as the bundle is installed."]
    pub fn celix_bundle_getDescription(bnd: *const celix_bundle_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the update location of the bundle.\n The location the location passed to celix_bundleContext_installBundle when a bundle is installed.\n For the framework bundle, the location will be NULL.\n\n @return The update location of the bundle or NULL if the bundle is the framework bundle.\n The caller is responsible for freeing the returned string."]
    pub fn celix_bundle_getLocation(bnd: *const celix_bundle_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return the bundle version.\n Note the return value is valid as long as the bundle is installed."]
    pub fn celix_bundle_getVersion(bnd: *const celix_bundle_t) -> *const celix_version_t;
}
extern "C" {
    #[doc = " @brief Return whether the bundle is the system bundle."]
    pub fn celix_bundle_isSystemBundle(bnd: *const celix_bundle_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_bundle_service_list_entry {
    pub serviceId: ::std::os::raw::c_long,
    pub bundleOwner: ::std::os::raw::c_long,
    pub serviceName: *mut ::std::os::raw::c_char,
    pub serviceProperties: *mut celix_properties_t,
    pub factory: bool,
}
#[test]
fn bindgen_test_layout_celix_bundle_service_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<celix_bundle_service_list_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_bundle_service_list_entry>(),
        40usize,
        concat!("Size of: ", stringify!(celix_bundle_service_list_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_bundle_service_list_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_bundle_service_list_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_list_entry),
            "::",
            stringify!(serviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bundleOwner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_list_entry),
            "::",
            stringify!(bundleOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_list_entry),
            "::",
            stringify!(serviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceProperties) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_list_entry),
            "::",
            stringify!(serviceProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_list_entry),
            "::",
            stringify!(factory)
        )
    );
}
pub type celix_bundle_service_list_entry_t = celix_bundle_service_list_entry;
extern "C" {
    #[doc = " Return a array list of registered service info entries for this bundle.\n\n @param ctx       The bundle context\n @param bndId     The bundle id for which the services should be listed\n @return          A celix array list with celix_bundle_service_list_entry_t*. Caller is owner of the celix array."]
    pub fn celix_bundle_listRegisteredServices(
        bnd: *const celix_bundle_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " Utils function to free memory for the return of a celix_bundle_listRegisteredServices call."]
    pub fn celix_bundle_destroyRegisteredServicesList(list: *mut celix_array_list_t);
}
#[doc = " Service Tracker Info provided to the service tracker tracker callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_bundle_service_tracker_list_entry {
    pub filter: *mut ::std::os::raw::c_char,
    pub serviceName: *mut ::std::os::raw::c_char,
    pub bundleOwner: ::std::os::raw::c_long,
    pub nrOfTrackedServices: usize,
}
#[test]
fn bindgen_test_layout_celix_bundle_service_tracker_list_entry() {
    const UNINIT: ::std::mem::MaybeUninit<celix_bundle_service_tracker_list_entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_bundle_service_tracker_list_entry>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(celix_bundle_service_tracker_list_entry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<celix_bundle_service_tracker_list_entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(celix_bundle_service_tracker_list_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_tracker_list_entry),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_tracker_list_entry),
            "::",
            stringify!(serviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bundleOwner) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_tracker_list_entry),
            "::",
            stringify!(bundleOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrOfTrackedServices) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_service_tracker_list_entry),
            "::",
            stringify!(nrOfTrackedServices)
        )
    );
}
#[doc = " Service Tracker Info provided to the service tracker tracker callbacks."]
pub type celix_bundle_service_tracker_list_entry_t = celix_bundle_service_tracker_list_entry;
extern "C" {
    #[doc = " Returns a array list of service tracker info entries for this bundle.\n\n @warning It requires a valid bundle context. Calling it for an inactive bundle will lead to crash.\n\n @param ctx       The bundle context\n @param bndId     The bundle id for which the services should be listed\n @return          A celix array list with celix_bundle_service_tracker_list_entry_t*. Caller is owner of the celix\n array. The returned list should be freed using celix_arrayList_destroy."]
    pub fn celix_bundle_listServiceTrackers(bnd: *const celix_bundle_t) -> *mut celix_array_list_t;
}
pub type celix_service_factory_t = celix_service_factory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_factory {
    pub handle: *mut ::std::os::raw::c_void,
    pub getService: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            requestingBundle: *const celix_bundle_t,
            svcProperties: *const celix_properties_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub ungetService: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            requestingBundle: *const celix_bundle_t,
            svcProperties: *const celix_properties_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_celix_service_factory() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_factory> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_factory>(),
        24usize,
        concat!("Size of: ", stringify!(celix_service_factory))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_factory>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_service_factory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_factory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getService) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_factory),
            "::",
            stringify!(getService)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ungetService) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_factory),
            "::",
            stringify!(ungetService)
        )
    );
}
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_INSTALLED: celix_bundle_event_type = 1;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_STARTED: celix_bundle_event_type = 2;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_STOPPED: celix_bundle_event_type = 3;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_UPDATED: celix_bundle_event_type = 4;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_UNINSTALLED: celix_bundle_event_type = 5;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_RESOLVED: celix_bundle_event_type = 6;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_UNRESOLVED: celix_bundle_event_type = 7;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_STARTING: celix_bundle_event_type = 8;
pub const celix_bundle_event_type_CELIX_BUNDLE_EVENT_STOPPING: celix_bundle_event_type = 9;
pub type celix_bundle_event_type = ::std::os::raw::c_uint;
pub use self::celix_bundle_event_type as celix_bundle_event_type_e;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_bundle_event {
    pub bnd: *mut celix_bundle_t,
    pub bundleSymbolicName: *mut ::std::os::raw::c_char,
    pub type_: celix_bundle_event_type_e,
}
#[test]
fn bindgen_test_layout_celix_bundle_event() {
    const UNINIT: ::std::mem::MaybeUninit<celix_bundle_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_bundle_event>(),
        24usize,
        concat!("Size of: ", stringify!(celix_bundle_event))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_bundle_event>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_bundle_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_event),
            "::",
            stringify!(bnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bundleSymbolicName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_event),
            "::",
            stringify!(bundleSymbolicName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_event),
            "::",
            stringify!(type_)
        )
    );
}
pub type celix_bundle_event_t = celix_bundle_event;
pub const celix_log_level_CELIX_LOG_LEVEL_TRACE: celix_log_level = 0;
pub const celix_log_level_CELIX_LOG_LEVEL_DEBUG: celix_log_level = 1;
pub const celix_log_level_CELIX_LOG_LEVEL_INFO: celix_log_level = 2;
pub const celix_log_level_CELIX_LOG_LEVEL_WARNING: celix_log_level = 3;
pub const celix_log_level_CELIX_LOG_LEVEL_ERROR: celix_log_level = 4;
pub const celix_log_level_CELIX_LOG_LEVEL_FATAL: celix_log_level = 5;
pub const celix_log_level_CELIX_LOG_LEVEL_DISABLED: celix_log_level = 6;
pub type celix_log_level = ::std::os::raw::c_uint;
pub use self::celix_log_level as celix_log_level_e;
extern "C" {
    #[doc = " @brief Converts a log level to a string.\n @param level The log level to convert.\n @return The string representation of the log level."]
    pub fn celix_logLevel_toString(level: celix_log_level_e) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Converts a string to a log level.\n @param[in] str The string to convert.\n @param[in] fallbackLogLevel The log level to return if the string is not a valid log level.\n @return The log level."]
    pub fn celix_logLevel_fromString(
        str_: *const ::std::os::raw::c_char,
        fallbackLogLevel: celix_log_level_e,
    ) -> celix_log_level_e;
}
extern "C" {
    #[doc = " @brief Converts a string to a log level.\n @param[in] str The string to convert.\n @param[in] fallbackLogLevel The log level to return if the string is not a valid log level.\n @param[out] convertedSuccessfully A pointer to a boolean which will be set to true if the string is a valid log\n level, false otherwise. Can be NULL if the caller is not interested in this information.\n @return The log level."]
    pub fn celix_logLevel_fromStringWithCheck(
        str_: *const ::std::os::raw::c_char,
        fallbackLogLevel: celix_log_level_e,
        convertedSuccessfully: *mut bool,
    ) -> celix_log_level_e;
}
extern "C" {
    #[doc = " @brief Register a service to the Celix framework.\n\n The service will be registered async on the Celix event loop thread. This means that service registration is (probably)\n not yet concluded when this function returns, but is added to the event loop.\n Use celix_bundleContext_waitForAsyncRegistration to synchronise with the\n actual service registration in the framework's service registry.\n\n @param ctx The bundle context\n @param svc the service object. Normally a pointer to a service struct (i.e. a struct with function pointers)\n @param serviceName the service name, cannot be NULL\n @param properties The meta properties associated with the service. The service registration will take ownership of the properties (i.e. no destroy needed)\n @return The serviceId (>=0) or -1 if the registration was unsuccessful."]
    pub fn celix_bundleContext_registerServiceAsync(
        ctx: *mut celix_bundle_context_t,
        svc: *mut ::std::os::raw::c_void,
        serviceName: *const ::std::os::raw::c_char,
        properties: *mut celix_properties_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Register a service to the Celix framework.\n\n Note: Please use the celix_bundleContext_registerServiceAsync instead.\n\n @param ctx The bundle context\n @param svc the service object. Normally a pointer to a service struct (i.e. a struct with function pointers)\n @param serviceName the service name, cannot be NULL\n @param properties The meta properties associated with the service. The service registration will take ownership of the properties (i.e. no destroy needed)\n @return The serviceId (>=0) or -1 if the registration was unsuccessful."]
    pub fn celix_bundleContext_registerService(
        ctx: *mut celix_bundle_context_t,
        svc: *mut ::std::os::raw::c_void,
        serviceName: *const ::std::os::raw::c_char,
        properties: *mut celix_properties_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Register a service factory in the framework.\n\n The service factory will be called for every bundle requesting/de-requesting a service. This gives the provider the\n option to create bundle specific service instances.\n\n When a service is requested for a bundle the getService of the factory service will be called. This function must\n return a valid pointer to a service conform the registered service name or NULL.\n When a service in no longer needed for a bundle (e.g. ending the useService(s) calls or when a service tracker is stopped)\n the ungetService function of the service factory will be called.\n\n The service will be registered async on the Celix event loop thread. This means that service registration is (probably)\n not yet concluded when this function returns, but is added to the event loop.\n Use celix_bundleContext_waitForAsyncRegistration to synchronise with the\n actual service registration in the framework's service registry.\n\n @param ctx The bundle context\n @param factory The pointer to the factory service.\n @param serviceName The required service name of the services this factory will produce.\n @param properties The optional service factory properties. For a service consumer this will be seen as the service properties.\n @return The serviceId (>= 0) or < 0 if the registration was unsuccessful."]
    pub fn celix_bundleContext_registerServiceFactoryAsync(
        ctx: *mut celix_bundle_context_t,
        factory: *mut celix_service_factory_t,
        serviceName: *const ::std::os::raw::c_char,
        props: *mut celix_properties_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Register a service factory in the framework.\n\n The service factory will be called for every bundle requesting/de-requesting a service. This gives the provider the\n option to create bundle specific service instances.\n Note: Please use the celix_bundleContext_registerServiceFactoryAsync instead.\n\n When a service is requested for a bundle the getService of the factory service will be called. This function must\n return a valid pointer to a service conform the registered service name or NULL.\n When a service in no longer needed for a bundle (e.g. ending the useService(s) calls or when a service tracker is stopped)\n the ungetService function of the service factory will be called.\n\n @param ctx The bundle context\n @param factory The pointer to the factory service.\n @param serviceName The required service name of the services this factory will produce.\n @param properties The optional service factory properties. For a service consumer this will be seen as the service properties.\n @return The serviceId (>= 0) or < 0 if the registration was unsuccessful."]
    pub fn celix_bundleContext_registerServiceFactory(
        ctx: *mut celix_bundle_context_t,
        factory: *mut celix_service_factory_t,
        serviceName: *const ::std::os::raw::c_char,
        props: *mut celix_properties_t,
    ) -> ::std::os::raw::c_long;
}
#[doc = " @brief Service Registration Options when registering services to the Celix framework."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_registration_options {
    #[doc = " @brief The service pointer.\n\n The actual pointer to the service. For C this is normally a pointer to a struct\n with function pointers, but theoretically this can be a pointer to anything (e.g. a pointer to a single function,\n or a pointer to a C++ interface implementation, or just a pointer to a data structure).\n\n The bundle is responsible to keep the service pointer valid as long as it is registered in the Celix framework."]
    pub svc: *mut ::std::os::raw::c_void,
    #[doc = " @brief The service factory pointer.\n\n Note if the factory service is set, the svc field will not be used.\n\n The service factory will be called for every bundle requesting/de-requesting a service. This gives the provider the\n option to create bundle specific service instances.\n\n When a service is requested for a bundle the getService of the factory service will be called. This function must\n return a valid pointer to a service conform the registered service name or NULL.\n When a service in no longer needed for a bundle (e.g. ending the useService(s) calls when a service tacker is stopped)\n the ungetService function of the service factory will be called.\n\n The bundle is responsible to keep the service factory pointer valid as long as it is registered in the Celix framework."]
    pub factory: *mut celix_service_factory_t,
    #[doc = " @brief The required service name.\n\n This is used to identify the service. A fully qualified name with a namespace is\n advisable to prevent name collision. (e.g. EXAMPLE_PRESSURE_SENSOR)."]
    pub serviceName: *const ::std::os::raw::c_char,
    #[doc = " @brief The optional service properties.\n\n These contain meta information about the service in the\n form of string key/values. (e.g. the location of a pressure sensor: location=left-tire).\n\n When a service is registered the Celix framework will take ownership of the provided properties.\n If a registration fails, the properties will be destroyed (freed) by the Celix framework."]
    pub properties: *mut celix_properties_t,
    #[doc = " @brief The optional service version (in the form of <MAJOR>.<MINOR>.<MICRO>.<QUALIFIER>).\n\n If present consumer of the service can specific which service version range of\n a specific service they are interested in. Note that it is the responsibility of the users to ensure that\n service in those version range are compatible (binary of source). It is advisable to use semantic versioning\n for this."]
    pub serviceVersion: *const ::std::os::raw::c_char,
    #[doc = " @brief Async data pointer for the async register callback."]
    pub asyncData: *mut ::std::os::raw::c_void,
    #[doc = " @brief Async callback.\n\n Will be called after the a service is registered in the service registry using a async call.\n Will be called on the Celix event loop.\n\n If a asyns service registration is combined with a _sync_ service unregistration, it can happen that\n unregistration happens before the registration event is processed. In this case the asyncCallback\n will not be called."]
    pub asyncCallback: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, serviceId: ::std::os::raw::c_long),
    >,
}
#[test]
fn bindgen_test_layout_celix_service_registration_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_registration_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_registration_options>(),
        56usize,
        concat!("Size of: ", stringify!(celix_service_registration_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_registration_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(celix_service_registration_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(svc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(factory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(serviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceVersion) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(serviceVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asyncData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(asyncData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asyncCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_options),
            "::",
            stringify!(asyncCallback)
        )
    );
}
#[doc = " @brief Service Registration Options when registering services to the Celix framework."]
pub type celix_service_registration_options_t = celix_service_registration_options;
extern "C" {
    #[doc = " @brief Register a service to the Celix framework using the provided service registration options.\n\n The service will be registered async on the Celix event loop thread. This means that service registration is (probably)\n not yet concluded when this function returns, but is added to the event loop..\n Use celix_bundleContext_waitForAsyncRegistration to synchronise with the\n actual service registration in the framework's service registry.\n\n @param ctx The bundle context\n @param opts The pointer to the registration options. The options are only in the during registration call.\n @return The serviceId (>= 0) or -1 if the registration was unsuccessful and -2 if the registration was cancelled (@see celix_bundleContext_reserveSvcId)."]
    pub fn celix_bundleContext_registerServiceWithOptionsAsync(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_registration_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Register a service to the Celix framework using the provided service registration options.\n\n Note: Please use the celix_bundleContext_registerServiceAsyncWithOptions instead.\n\n @param ctx The bundle context\n @param opts The pointer to the registration options. The options are only in the during registration call.\n @return The serviceId (>= 0) or -1 if the registration was unsuccessful and -2 if the registration was cancelled (@see celix_bundleContext_reserveSvcId)."]
    pub fn celix_bundleContext_registerServiceWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_registration_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Waits til the async service registration for the provided serviceId is done.\n\n Silently ignore service ids < 0.\n Will directly return if there is no pending service registration for the provided service id."]
    pub fn celix_bundleContext_waitForAsyncRegistration(
        ctx: *mut celix_bundle_context_t,
        serviceId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Checks whether a service for the provided service id is registered in the service registry.\n\n Note return false if the service for the provided service id is still pending in the event loop.\n Silently ignore service ids < 0 (returns false).\n\n Returns true if the service is registered in the service registry."]
    pub fn celix_bundleContext_isServiceRegistered(
        ctx: *mut celix_bundle_context_t,
        serviceId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Unregister the service or service factory with service id.\n\n The service will only be unregistered if the bundle of the bundle context is the owner of the service.\n\n Will log an error if service id is unknown. Will silently ignore services ids < 0.\n\n @param ctx The bundle context\n @param serviceId The service id"]
    pub fn celix_bundleContext_unregisterService(
        ctx: *mut celix_bundle_context_t,
        serviceId: ::std::os::raw::c_long,
    );
}
#[doc = " @brief Service registration guard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_registration_guard {
    pub ctx: *mut celix_bundle_context_t,
    pub svcId: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_celix_service_registration_guard() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_registration_guard> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_registration_guard>(),
        16usize,
        concat!("Size of: ", stringify!(celix_service_registration_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_registration_guard>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(celix_service_registration_guard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_guard),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svcId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_registration_guard),
            "::",
            stringify!(svcId)
        )
    );
}
#[doc = " @brief Service registration guard."]
pub type celix_service_registration_guard_t = celix_service_registration_guard;
extern "C" {
    #[doc = " @brief Unregister the service or service factory with service id.\n\n The service will only be unregistered if the bundle of the bundle context is the owner of the service.\n\n The service will be umregistered async on the Celix event loop thread. This means that service unregistration is (probably)\n not yet concluded when this function returns. Use celix_bundleContext_waitForAsyncUnregistration to synchronise with the\n actual service unregistration in the framework's service registry.\n\n @param ctx The bundle context\n @param serviceId The service id\n @param doneData The data used on the doneCallback (if present)\n @param doneCallback If not NULL, this callback will be called when the unregisration is done. (will be called on the event loop thread)"]
    pub fn celix_bundleContext_unregisterServiceAsync(
        ctx: *mut celix_bundle_context_t,
        serviceId: ::std::os::raw::c_long,
        doneData: *mut ::std::os::raw::c_void,
        doneCallback: ::std::option::Option<
            unsafe extern "C" fn(doneData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Waits til the async service unregistration for the provided serviceId is done.\n\n Silently ignore service < 0."]
    pub fn celix_bundleContext_waitForAsyncUnregistration(
        ctx: *mut celix_bundle_context_t,
        serviceId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Finds the highest ranking service and returns the service id.\n\n @param ctx The bundle context\n @param serviceName The required service name\n @return If found a valid service id (>= 0) if not found -1."]
    pub fn celix_bundleContext_findService(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Finds the services with the provided service name and returns a list of the found service ids.\n\n @param ctx The bundle context\n @param serviceName The required service name\n @return A array list with as value a long int."]
    pub fn celix_bundleContext_findServices(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
    ) -> *mut celix_array_list_t;
}
#[doc = " @brief Service filter options which can be used to query for certain services."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_filter_options {
    #[doc = " @brief The service name.\n\n If NULL is used any services which matches the filter string will be tracked."]
    pub serviceName: *const ::std::os::raw::c_char,
    #[doc = " @brief The optional version range.\n\n If service are registered with a service version this attribute can be used to\n only select service with a version in the version range.\n It uses the maven version range format, e.g. [1.0.0,2.0.0) or [1.1.1], etc."]
    pub versionRange: *const ::std::os::raw::c_char,
    #[doc = " @brief LDAP filter to use for fine tuning the filtering, e.g. (|(location=middle)(location=front))\n\n The filter will be applied to all the user provided and framework provided service properties."]
    pub filter: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_celix_service_filter_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_filter_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_filter_options>(),
        24usize,
        concat!("Size of: ", stringify!(celix_service_filter_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_filter_options>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_service_filter_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_filter_options),
            "::",
            stringify!(serviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).versionRange) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_filter_options),
            "::",
            stringify!(versionRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_filter_options),
            "::",
            stringify!(filter)
        )
    );
}
#[doc = " @brief Service filter options which can be used to query for certain services."]
pub type celix_service_filter_options_t = celix_service_filter_options;
extern "C" {
    #[doc = " @brief Finds the highest ranking service and returns the service id.\n\n @param ctx The bundle context\n @param opts The pointer to the filter options.\n @return If found a valid service id (>= 0) if not found -1."]
    pub fn celix_bundleContext_findServiceWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_filter_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Finds the services conform the provider filter options and returns a list of the found service ids.\n\n @param ctx The bundle context\n @param opts The pointer to the filter options.\n @return A array list with as value a long int."]
    pub fn celix_bundleContext_findServicesWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_filter_options_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Use the service with the provided service id using the provided callback. The Celix framework will ensure that\n the targeted service cannot be removed during the callback.\n\n @warning Cannot be called from the Celix event thread.\n\n @deprecated celix_bundleContext_useServiceWithId is deprecated and should be considered test utils functions. In\n operational code use celix_bundleContext_trackService* combined with celix_bundleContext_useTrackedService*\n functions instead.\n\n The Celix framework will ensure that the targeted service cannot be removed during the callback and the callback\n is called on the calling thread.\n\n This function will block until the callback is finished. As result it is possible to provide callback data from the\n stack.\n\n @param ctx The bundle context\n @param serviceId the service id.\n @param serviceName the service name of the service. Should match with the registered service name of the provided\n service id (sanity check)\n @param callbackHandle The data pointer, which will be used in the callbacks\n @param use The callback, which will be called when service is retrieved.\n @param bool returns true if a service was found and the callback was called."]
    pub fn celix_bundleContext_useServiceWithId(
        ctx: *mut celix_bundle_context_t,
        serviceId: ::std::os::raw::c_long,
        serviceName: *const ::std::os::raw::c_char,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                svc: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Use the highest ranking service with the provided service name using the provided callback.\n\n @warning Cannot be called from the Celix event thread.\n\n @deprecated celix_bundleContext_useService is deprecated and should be considered test utils functions. In\n operational code use celix_bundleContext_trackService* combined with celix_bundleContext_useTrackedService* functions\n instead.\n\n The Celix framework will ensure that the targeted service cannot be removed during the callback and the callback\n is called on the calling thread.\n\n The svc is should only be considered valid during the callback.\n If no service is found, the callback will not be invoked and this function will return false immediately.\n\n This function will block until the callback is finished. As result it is possible to provide callback data from the\n stack.\n\n @param   ctx The bundle context\n @param   serviceName the required service name.\n @param   callbackHandle The data pointer, which will be used in the callbacks\n @param   use The callback, which will be called when service is retrieved.\n @return  True if a service was found and the callback was called."]
    pub fn celix_bundleContext_useService(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                svc: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Use the services with the provided service name using the provided callback.\n\n @warning Cannot be called from the Celix event thread.\n\n @deprecated celix_bundleContext_useServices is deprecated and should be considered test utils functions. In\n operational code use celix_bundleContext_trackService* combined with celix_bundleContext_useTrackedService* functions\n instead.\n\n The Celix framework will ensure that the targeted service cannot be removed during the callback and the callback\n is called on the calling thread.\n\n The svc is should only be considered valid during the callback.\n If no service is found, the callback will not be invoked and this function will return 0 immediately.\n\n This function will block until the callback is finished. As result it is possible to provide callback data from the\n stack.\n\n @param   ctx The bundle context\n @param   serviceName the required service name.\n @param   callbackHandle The data pointer, which will be used in the callbacks\n @param   use The callback, which will be called for every service found.\n @return  The number of services found and called."]
    pub fn celix_bundleContext_useServices(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                svc: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> usize;
}
#[doc = " @brief Service Use Options used to fine tune which services to use and which callbacks to use.\n\n If multiple use callbacks are set, all set callbacks will be called for every service found."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_use_options {
    #[doc = " @brief The service filter options, used to setup the filter for the service to track."]
    pub filter: celix_service_filter_options_t,
    #[doc = " @brief An optional timeout (in seconds), if > 0 the use service call will block until the timeout is expired or\n when at least one service is found. Note that it will be ignored when use service on the event loop.\n Default (0)\n\n Only applicable when using the celix_bundleContext_useService or\n celix_bundleContext_useServiceWithOptions (use single service calls)."]
    pub waitTimeoutInSeconds: f64,
    #[doc = " @brief The optional callback pointer used in all the provided callback function (use, useWithProperties, and\n useWithOwner)."]
    pub callbackHandle: *mut ::std::os::raw::c_void,
    #[doc = " @brief The optional use callback will be called when for every services found conform the service filter options\n - in case of findServices - or only for the highest ranking service found - in case of findService -.\n\n @param handle The callbackHandle pointer as provided in the service tracker options.\n @param svc The service pointer of the highest ranking service."]
    pub use_: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, svc: *mut ::std::os::raw::c_void),
    >,
    #[doc = " @brief The optional useWithProperties callback is handled as the use callback, but with the addition that the\n service properties will also be provided to the callback."]
    pub useWithProperties: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
        ),
    >,
    #[doc = " @brief The optional useWithOwner callback is handled as the yse callback, but with the addition that the service\n properties and the bundle owning the service will also be provided to the callback."]
    pub useWithOwner: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
            svcOwner: *const celix_bundle_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_celix_service_use_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_use_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_use_options>(),
        64usize,
        concat!("Size of: ", stringify!(celix_service_use_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_use_options>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_service_use_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_use_options),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waitTimeoutInSeconds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_use_options),
            "::",
            stringify!(waitTimeoutInSeconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_use_options),
            "::",
            stringify!(callbackHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_use_options),
            "::",
            stringify!(use_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useWithProperties) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_use_options),
            "::",
            stringify!(useWithProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useWithOwner) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_use_options),
            "::",
            stringify!(useWithOwner)
        )
    );
}
#[doc = " @brief Service Use Options used to fine tune which services to use and which callbacks to use.\n\n If multiple use callbacks are set, all set callbacks will be called for every service found."]
pub type celix_service_use_options_t = celix_service_use_options;
extern "C" {
    #[doc = " @brief Use the highest ranking service satisfying the provided service filter options using the provided callback.\n\n @note celix_bundleContext_useService should be considered a test util function.\n For production code, use celix_bundleContext_trackService* combined with celix_bundleContext_useTrackedService*\n functions instead.\n\n The Celix framework will ensure that the targeted service cannot be removed during the callback.\n\n The svc is should only be considered valid during the callback.\n If no service is found the callback will not be invoked. In such cases, if a non-zero waitTimeoutInSeconds is specified in opts,\n this function will block until the timeout is expired or when at least one service is found, otherwise it will return false immediately.\n\n This function will block until the callback is finished. As result it is possible to provide callback data from the\n stack.\n\n @param   ctx The bundle context.\n @param   opts The required options. Note that the serviceName is required.\n @return  True if a service was found."]
    pub fn celix_bundleContext_useServiceWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_use_options_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Use the services with the provided service filter options using the provided callback.\n\n @note celix_bundleContext_useService should be considered test utils functions.\n For production code, use celix_bundleContext_trackService* combined with celix_bundleContext_useTrackedService*\n functions instead.\n\n The Celix framework will ensure that the targeted service cannot be removed during the callback.\n\n The svc is should only be considered valid during the callback.\n If no service is found, the callback will not be invoked and this function will return 0 immediately.\n Note that waitTimeoutInSeconds in opts has no effect.\n\n This function will block until the callback is finished. As result it is possible to provide callback data from the\n stack.\n\n @param   ctx The bundle context.\n @param   opts The required options. Note that the serviceName is required.\n @return  The number of services found and called"]
    pub fn celix_bundleContext_useServicesWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_use_options_t,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Track services with the provided serviceName.\n\n The service tracker will be created async on the Celix event loop thread. This means that the function can return\n before the tracker is created.\n\n @param ctx The bundle context.\n @param serviceName The required service name to track\n                    If NULL is all service are tracked.\n @return the tracker id (>=0) or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackServicesAsync(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Track services with the provided serviceName.\n\n Note: If possible, use the celix_bundleContext_trackServicesAsync instead.\n\n @param ctx The bundle context.\n @param serviceName The required service name to track\n                    If NULL is all service are tracked.\n @return the tracker id (>=0) or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackServices(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
#[doc = " @brief Service Tracker Options used to fine tune which services to track and the callback to be used for the tracked\n services."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_tracking_options {
    #[doc = " @brief The service filter options, used to setup the filter for the service to track."]
    pub filter: celix_service_filter_options_t,
    #[doc = " @brief The optional callback pointer used in all the provided callback function (set, add, remove,\n setWithProperties, etc)."]
    pub callbackHandle: *mut ::std::os::raw::c_void,
    #[doc = " @brief The optional set callback will be called when a new highest ranking service is available conform the\n provided service filter options.\n @param handle The callbackHandle pointer as provided in the service tracker options.\n @param svc The service pointer of the highest ranking service."]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, svc: *mut ::std::os::raw::c_void),
    >,
    #[doc = " @brief The optional setWithProperties callback is handled as the set callback, but with the addition that the\n service properties will also be provided to the callback."]
    pub setWithProperties: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
        ),
    >,
    #[doc = " @brief The optional setWithOwner callback is handled as the set callback, but with the addition that the service\n properties and the bundle owning the service will also be provided to the callback."]
    pub setWithOwner: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
            svcOwner: *const celix_bundle_t,
        ),
    >,
    #[doc = " @brief The optional add callback will be called for every current and future service found conform the provided\n service filter options as long as the tracker is active.\n @param handle The callbackHandle pointer as provided in the service tracker options.\n @param svc The service pointer of a service matching the provided service filter options."]
    pub add: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, svc: *mut ::std::os::raw::c_void),
    >,
    #[doc = " @brief The optional addWithProperties callback is handled as the add callback, but with the addition that the\n service properties will also be provided to the callback."]
    pub addWithProperties: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
        ),
    >,
    #[doc = " @brief The optional addWithOwner callback is handled as the add callback, but with the addition that the service\n properties and the bundle owning the service will also be provided to the callback."]
    pub addWithOwner: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
            svcOwner: *const celix_bundle_t,
        ),
    >,
    #[doc = " @brief The optional remove callback will be called for every service conform the provided service filter options\n that is unregistered. When the remove call is finished the removed services should be considered invalid. This\n means that the callback provider should ensure that the removed service is not in use or going to be used after\n the remove callback is finished.\n\n @param handle The callbackHandle pointer as provided in the service tracker options.\n @param svc The service pointer of a service matching the provided service filter options."]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, svc: *mut ::std::os::raw::c_void),
    >,
    #[doc = " @brief The optional removeWithProperties callback is handled as the remove callback, but with the addition that\n the service properties will also be provided to the callback."]
    pub removeWithProperties: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
        ),
    >,
    #[doc = " @brief The optional removeWithOwner callback is handled as the remove callback, but with the addition that the\n service properties and the bundle owning the service will also be provided to the callback."]
    pub removeWithOwner: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
            svcOwner: *const celix_bundle_t,
        ),
    >,
    #[doc = " @brief Data for the trackerCreatedCallback."]
    pub trackerCreatedCallbackData: *mut ::std::os::raw::c_void,
    #[doc = " @brief The callback called when the tracker has ben created (and is active) when using a async call.\n\n If a asyns track service is combined with a _sync_ stop tracker, it can happen that\n \"stop tracker\" happens before the \"create tracker\" event is processed. In this case the asyncCallback\n will not be called."]
    pub trackerCreatedCallback: ::std::option::Option<
        unsafe extern "C" fn(trackerCreatedCallbackData: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_celix_service_tracking_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_tracking_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_tracking_options>(),
        120usize,
        concat!("Size of: ", stringify!(celix_service_tracking_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_tracking_options>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_service_tracking_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(callbackHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setWithProperties) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(setWithProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setWithOwner) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(setWithOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addWithProperties) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(addWithProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addWithOwner) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(addWithOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removeWithProperties) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(removeWithProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removeWithOwner) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(removeWithOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trackerCreatedCallbackData) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(trackerCreatedCallbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trackerCreatedCallback) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracking_options),
            "::",
            stringify!(trackerCreatedCallback)
        )
    );
}
#[doc = " @brief Service Tracker Options used to fine tune which services to track and the callback to be used for the tracked\n services."]
pub type celix_service_tracking_options_t = celix_service_tracking_options;
extern "C" {
    #[doc = " @brief Tracks services using the provided tracker options.\n\n The tracker options are only using during this call and can safely be freed/reused after this call returns.\n\n The service tracker will be created async on the Celix event loop thread. This means that the function can return\n before the tracker is created.\n\n @param ctx The bundle context.\n @param opts The pointer to the tracker options.\n @return the tracker id (>=0) or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackServicesWithOptionsAsync(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_tracking_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Tracks services using the provided tracker options.\n\n The tracker options are only using during this call and can safely be freed/reused after this call returns.\n Note: Please use the celix_bundleContext_registerServiceFactoryAsync instead.\n\n @param ctx The bundle context.\n @param opts The pointer to the tracker options.\n @return the tracker id (>=0) or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackServicesWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_service_tracking_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Use the highest-ranking service tracked by the specified tracker id by invoking the provided use callback.\n\n The callback is executed on the thread that invokes this function, and the function waits until the use callback\n is completed before returning.\n\n A tracker id less than 0 is ignored without action. An invalid (non-existent) tracker id of 0 or greater results\n in a logged error, and the function returns false.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The service tracker id.\n @param[in] callbackHandle An optional pointer to a user-defined context or data structure, passed to the provided use\n callback function.\n @param[in] use The use callback invoked for highest-ranking service tracked.\n @return True if a service was found and the provided use callback was executed; false if the tracker is not yet\n active (asynchronous tracker creation), the are no matching services tracked or if the tracker id is invalid."]
    pub fn celix_bundleContext_useTrackedService(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                svc: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Use the services tracked by the specified tracker id by invoking the provided use callback.\n\n The callback is executed on the thread that invokes this function, and the function waits until the use callback,\n called for all tracked. services, is completed before returning.\n\n A tracker id less than 0 is ignored without action. An invalid (non-existent) tracker id of 0 or greater results\n in a logged error, and the function returns 0.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The service tracker id.\n @param[in] callbackHandle An optional pointer to a user-defined context or data structure, passed to the provided use\n callback function.\n @param[in] use The use callback invoked for all tracked services.\n @return The number of services found. Returns 0 if the tracker\n is not yet active (asynchronous tracker creation), 0 services are found or if the tracker id is invalid."]
    pub fn celix_bundleContext_useTrackedServices(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                svc: *mut ::std::os::raw::c_void,
            ),
        >,
    ) -> usize;
}
#[doc = " @brief Options for using services tracked by a service tracker. These options enable specifying callbacks\n to be invoked for each tracked service that matches the selection criteria. If multiple callbacks are provided,\n each will be called for every matching service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_tracked_service_use_options {
    #[doc = " @brief An optional pointer to a user-defined context or data structure, passed to all specified callback\n functions (use, useWithProperties, and useWithOwner).\n\n Default value: NULL."]
    pub callbackHandle: *mut ::std::os::raw::c_void,
    #[doc = " @brief An optional callback invoked for each tracked service that matches the selection criteria.\n This callback does not receive the service's properties or information about the service's owning bundle.\n\n The svc pointer is only valid during the callback.\n\n Default value: NULL."]
    pub use_: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, svc: *mut ::std::os::raw::c_void),
    >,
    #[doc = " @brief An optional callback invoked for each tracked service that matches the selection criteria,\n providing the service's properties. This enables the callback to utilize additional metadata associated\n with the service.\n\n The svc and props pointers are only valid during the callback.\n\n Default value: NULL."]
    pub useWithProperties: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
        ),
    >,
    #[doc = " @brief An optional callback invoked for each tracked service that matches the selection criteria,\n along with the service's properties and the service's owning bundle.\n\n The svc, props, and svcOwner pointers are only valid during the callback.\n\n Default value: NULL."]
    pub useWithOwner: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            svc: *mut ::std::os::raw::c_void,
            props: *const celix_properties_t,
            svcOwner: *const celix_bundle_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_celix_tracked_service_use_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_tracked_service_use_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_tracked_service_use_options>(),
        32usize,
        concat!("Size of: ", stringify!(celix_tracked_service_use_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_tracked_service_use_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(celix_tracked_service_use_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_tracked_service_use_options),
            "::",
            stringify!(callbackHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_tracked_service_use_options),
            "::",
            stringify!(use_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useWithProperties) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_tracked_service_use_options),
            "::",
            stringify!(useWithProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useWithOwner) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_tracked_service_use_options),
            "::",
            stringify!(useWithOwner)
        )
    );
}
#[doc = " @brief Options for using services tracked by a service tracker. These options enable specifying callbacks\n to be invoked for each tracked service that matches the selection criteria. If multiple callbacks are provided,\n each will be called for every matching service."]
pub type celix_tracked_service_use_options_t = celix_tracked_service_use_options;
extern "C" {
    #[doc = " @brief Use the highest-ranking service tracked by the specified tracker id by invoking the callbacks\n specified in the provided options.\n\n The callbacks are executed on the thread that invokes this function, and the function waits until all callbacks\n are completed before returning.\n\n A tracker id less than 0 is ignored without action. An invalid (non-existent) tracker id of 0 or greater results\n in a logged error, and the function returns false.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The service tracker id.\n @param[in] opts The service use options containing callbacks and additional configurations.\n @return True if a service was found and the specified callbacks were executed; false if the tracker is not yet\n active (asynchronous tracker creation), the are no matching services tracked  or if the tracker id is invalid."]
    pub fn celix_bundleContext_useTrackedServiceWithOptions(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
        opts: *const celix_tracked_service_use_options_t,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Use the services tracked by the specified tracker id by invoking the callbacks specified in the\n provided options for each matching service.\n\n The callbacks are executed on the thread that invokes this function, and the function waits until all callbacks\n for all found services are completed before returning.\n\n A tracker id less than 0 is ignored without action. An invalid (non-existent) tracker id of 0 or greater results\n in a logged error, and the function returns 0.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The service tracker id.\n @param[in] opts The service use options containing callbacks and additional configurations.\n @return The number of services found and for which the specified callbacks were executed. Returns 0 if the tracker\n is not yet active (asynchronous tracker creation), 0 services are found or if the tracker id is invalid."]
    pub fn celix_bundleContext_useTrackedServicesWithOptions(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
        opts: *const celix_tracked_service_use_options_t,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Get the number of tracked services for the provided tracker id.\n\n Silently ignore tracker ids < 0 and invalid tracker ids.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The tracker id.\n @return The number of tracked services or 0 if the tracker id is unknown or < 0."]
    pub fn celix_bundleContext_getTrackedServiceCount(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Get the service name of the tracked services for the provided tracker id.\n\n Silently ignore tracker ids < 0 and invalid tracker ids.\n\n @param ctx The bundle context.\n @param trackerId The tracker id.\n @return The service name of the tracked services or NULL if the tracker id is unknown or < 0."]
    pub fn celix_bundleContext_getTrackedServiceName(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the service filter of the tracked services for the provided tracker id.\n\n The returned filter is the combination of the service name and the filter from the provided service filter options.\n For example serviceName=\"foo\" and filter=\"(location=middle)\" will result in a filter of\n \"(&(objectClass=foo)(location=middle))\"\n\n Silently ignore tracker ids < 0 and invalid tracker ids.\n\n @param ctx The bundle context.\n @param trackerId The tracker id.\n @return The service filter of the tracked services or NULL if the tracker id is unknown or < 0."]
    pub fn celix_bundleContext_getTrackedServiceFilter(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Stop the tracker with the provided track id.\n\n Could be a service tracker, bundle tracker or service tracker tracker.\n Only works for the trackers owned by the bundle of the bundle context.\n\n The service tracker will be destroyed async on the Celix event loop thread. This means that the function can return\n before the tracker is destroyed.\n\n if the doneCallback is not NULL, this will be called when the destruction of the service tracker is done.\n (will be called on the event loop thread).\n\n Will log a error if the provided tracker id is unknown. Will silently ignore trackerId < 0."]
    pub fn celix_bundleContext_stopTrackerAsync(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
        doneCallbackData: *mut ::std::os::raw::c_void,
        doneCallback: ::std::option::Option<
            unsafe extern "C" fn(doneCallbackData: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " @brief Wait, if able, for (async) creation of a tracker.\n\n Will silently ignore trackerId < 0 and log an error if the tracker id is unknown.\n If called on the Apache Celix event loop thread, the function will log a warning and return immediately.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The tracker id."]
    pub fn celix_bundleContext_waitForAsyncTracker(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Wait, if able, for (async) stopping of tracking.\n\n Will silently ignore trackerId < 0 and log an error if the tracker id is unknown.\n If called on the Apache Celix event loop thread, the function will log a warning and return immediately.\n\n @param[in] ctx The bundle context.\n @param[in] trackerId The tracker id."]
    pub fn celix_bundleContext_waitForAsyncStopTracker(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Stop the tracker with the provided track id.\n\n Could be a service tracker, bundle tracker or service tracker tracker.\n Only works for the trackers owned by the bundle of the bundle context.\n Note: Please use the celix_bundleContext_stopTrackerAsync instead.\n\n Will log a error if the provided tracker id is unknown. Will silently ignore trackerId < 0."]
    pub fn celix_bundleContext_stopTracker(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Returns true if the provided tracker id is a tracker id for an existing tracker for the provided bundle\n context.\n @param ctx The bundle context.\n @param trackerId The tracker id.\n @return True if the tracker id is valid."]
    pub fn celix_bundleContext_isValidTrackerId(
        ctx: *mut celix_bundle_context_t,
        trackerId: ::std::os::raw::c_long,
    ) -> bool;
}
#[doc = " @brief Tracker guard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_tracker_guard {
    pub ctx: *mut celix_bundle_context_t,
    pub trackerId: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_celix_tracker_guard() {
    const UNINIT: ::std::mem::MaybeUninit<celix_tracker_guard> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_tracker_guard>(),
        16usize,
        concat!("Size of: ", stringify!(celix_tracker_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_tracker_guard>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_tracker_guard))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_tracker_guard),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trackerId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_tracker_guard),
            "::",
            stringify!(trackerId)
        )
    );
}
#[doc = " @brief Tracker guard."]
pub type celix_tracker_guard_t = celix_tracker_guard;
extern "C" {
    #[doc = " @brief List the installed and started bundle ids.\n The bundle ids does not include the framework bundle (bundle id CELIX_FRAMEWORK_BUNDLE_ID).\n\n @param ctx The bundle context.\n @return A array with bundle ids (long). The caller is responsible for destroying the array."]
    pub fn celix_bundleContext_listBundles(
        ctx: *mut celix_bundle_context_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief List the installed bundle ids.\n The bundle ids does not include the framework bundle (bundle id CELIX_FRAMEWORK_BUNDLE_ID).\n\n @param ctx The bundle context.\n @return A array with bundle ids (long). The caller is responsible for destroying the array."]
    pub fn celix_bundleContext_listInstalledBundles(
        ctx: *mut celix_bundle_context_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Check whether a bundle is installed.\n @param ctx       The bundle context.\n @param bndId     The bundle id to check\n @return          true if the bundle is installed."]
    pub fn celix_bundleContext_isBundleInstalled(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check whether the bundle is active.\n @param ctx       The bundle context.\n @param bndId     The bundle id to check\n @return          true if the bundle is installed and active."]
    pub fn celix_bundleContext_isBundleActive(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Install and optional start a bundle.\n Will silently ignore bundle ids < 0.\n\n If this function is called on the Celix event thread and autoStart is true,\n the actual starting of the bundle will be done async and on a separate thread.\n If this function is called from a different thread than the Celix event thread and the autoStart is true,\n then the function will return after the bundle is started.\n\n @param ctx The bundle context\n @param bundleUrl The bundle location to the bundle zip file.\n @param autoStart If the bundle should also be started.\n @return the bundleId (>= 0) or < 0 if the bundle could not be installed and possibly started."]
    pub fn celix_bundleContext_installBundle(
        ctx: *mut celix_bundle_context_t,
        bundleUrl: *const ::std::os::raw::c_char,
        autoStart: bool,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Uninstall the bundle with the provided bundle id. If needed the bundle will be stopped first.\n Will silently ignore bundle ids < 0.\n\n If this function is called on the Celix event thread, the actual stopping of the bundle will be done async and\n on a separate thread.\n If this function is called from a different thread than the Celix event thread, then the function will return after\n the bundle is stopped.\n\n @param ctx The bundle context\n @param bndId The bundle id to uninstall.\n @return true if the bundle is correctly uninstalled. False if not."]
    pub fn celix_bundleContext_uninstallBundle(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Stop the bundle with the provided bundle id.\n Will silently ignore bundle ids < 0.\n\n If this function is called on the Celix event thread, the actual stopping of the bundle will be done async and\n on a separate thread.\n If this function is called from a different thread than the Celix event thread, then the function will return after\n the bundle is stopped.\n\n @param ctx The bundle context\n @param bndId The bundle id to stop.\n @return true if the bundle is found & correctly stop. False if not."]
    pub fn celix_bundleContext_stopBundle(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Start the bundle with the provided bundle id.\n Will silently ignore bundle ids < 0.\n\n If this function is called on the Celix event thread, the actual starting of the bundle will be done async and\n on a separate thread.\n If this function is called from a different thread than the Celix event thread, then the function will return after\n the bundle is started.\n\n @param ctx The bundle context\n @param bndId The bundle id to start.\n @return true if the bundle is found & correctly started. False if not."]
    pub fn celix_bundleContext_startBundle(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Update the bundle with the provided bundle id.\n\n This will do the following:\n  - unload the bundle with the specified bundle id;\n  - reload the bundle from the specified location with the specified bundle id;\n  - start the bundle, if it was previously active.\n\n Will silently ignore bundle ids < 0.\n\n Note if specified bundle location already exists in the bundle cache but with a different bundle id, the bundle\n will NOT be reinstalled, and the update is cancelled.\n\n If this function is called on the Celix event thread, the actual updating of the bundle will be done async and\n on a separate thread.\n If this function is called from a different thread than the Celix event thread, then the function will\n return after the bundle update is completed.\n\n @param ctx The bundle context\n @param bndId The bundle id to update.\n @param updatedBundleUrl The optional updated bundle url to the bundle zip file.\n If NULL, the existing bundle url from the bundle cache will be used, and the cache will only be updated if the zip file is newer.\n @return true if the bundle is found & correctly started. False if not."]
    pub fn celix_bundleContext_updateBundle(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
        updatedBundleUrl: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the bundle symbolic name for the provided bundle id.\n The caller is owner of the return string.\n\n @param ctx The bundle context\n @param bndId The bundle id to retrieve the symbolic name for.\n @return The bundle symbolic name or NULL if the bundle for the provided bundle id does not exist."]
    pub fn celix_bundleContext_getBundleSymbolicName(
        ctx: *mut celix_bundle_context_t,
        bndId: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Track bundles.\n\n The add bundle callback will also be called for already installed bundles.\n\n The bundle tracker will be created async on the Celix event loop thread. This means that the function can return\n before the tracker is created.\n\n @param ctx               The bundle context.\n @param callbackHandle    The data pointer, which will be used in the callbacks\n @param add               The callback which will be called for started bundles.\n @param remove            The callback which will be called when bundles are stopped.\n @return                  The bundle tracker id or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackBundlesAsync(
        ctx: *mut celix_bundle_context_t,
        callbackHandle: *mut ::std::os::raw::c_void,
        onStarted: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                bundle: *const celix_bundle_t,
            ),
        >,
        onStopped: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                bundle: *const celix_bundle_t,
            ),
        >,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Track bundles.\n\n The add bundle callback will also be called for already installed bundles.\n\n Note: please use celix_bundleContext_trackBundlesAsync instead.\n\n @param ctx               The bundle context.\n @param callbackHandle    The data pointer, which will be used in the callbacks\n @param add               The callback which will be called for started bundles.\n @param remove            The callback which will be called when bundles are stopped.\n @return                  The bundle tracker id or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackBundles(
        ctx: *mut celix_bundle_context_t,
        callbackHandle: *mut ::std::os::raw::c_void,
        onStarted: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                bundle: *const celix_bundle_t,
            ),
        >,
        onStopped: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                bundle: *const celix_bundle_t,
            ),
        >,
    ) -> ::std::os::raw::c_long;
}
#[doc = " @brief The Service Bundle Tracking options can be used to fine tune the requested bundle tracker options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_bundle_tracker_options {
    #[doc = " @brief The optional callback pointer used in all the provided callback function (set, add, remove, setWithProperties, etc)."]
    pub callbackHandle: *mut ::std::os::raw::c_void,
    #[doc = " @brief Tracker callback when a bundle is installed.\n @param handle    The handle, contains the value of the callbackHandle.\n @param bundle    The bundle which has been installed.\n                  The bundle pointer is only guaranteed to be valid during the callback."]
    pub onInstalled: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, bundle: *const celix_bundle_t),
    >,
    #[doc = " @brief Tracker callback when a bundle is started.\n @param handle    The handle, contains the value of the callbackHandle.\n @param bundle    The bundle which has been started.\n                  The bundle pointer is only guaranteed to be valid during the callback."]
    pub onStarted: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, bundle: *const celix_bundle_t),
    >,
    #[doc = " @brief Tracker callback when a bundle is stopped.\n @param handle    The handle, contains the value of the callbackHandle.\n @param bundle    The bundle which has been stopped.\n                  The bundle pointer is only guaranteed to be valid during the callback."]
    pub onStopped: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, bundle: *const celix_bundle_t),
    >,
    #[doc = " @param handle    The handle, contains the value of the callbackHandle.\n @param event     The bundle event. Is only valid during the callback."]
    pub onBundleEvent: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            event: *const celix_bundle_event_t,
        ),
    >,
    #[doc = " @brief Default the framework bundle (bundle id 0) will not trigger the callbacks.\n This is done, because the framework bundle is a special bundle which is generally not needed in the callbacks."]
    pub includeFrameworkBundle: bool,
    #[doc = " @brief Data for the trackerCreatedCallback."]
    pub trackerCreatedCallbackData: *mut ::std::os::raw::c_void,
    #[doc = " @brief The callback called when the tracker has ben created (and is active) when using the\n track bundles ascync calls.\n\n If a asyns track service is combined with a _sync_ stop tracker, it can happen that\n \"stop tracker\" happens before the \"create tracker\" event is processed. In this case the asyncCallback\n will not be called."]
    pub trackerCreatedCallback: ::std::option::Option<
        unsafe extern "C" fn(trackerCreatedCallbackData: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_celix_bundle_tracker_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_bundle_tracker_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_bundle_tracker_options>(),
        64usize,
        concat!("Size of: ", stringify!(celix_bundle_tracker_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_bundle_tracker_options>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_bundle_tracker_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(callbackHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onInstalled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(onInstalled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onStarted) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(onStarted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onStopped) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(onStopped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onBundleEvent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(onBundleEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).includeFrameworkBundle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(includeFrameworkBundle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trackerCreatedCallbackData) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(trackerCreatedCallbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trackerCreatedCallback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_bundle_tracker_options),
            "::",
            stringify!(trackerCreatedCallback)
        )
    );
}
#[doc = " @brief The Service Bundle Tracking options can be used to fine tune the requested bundle tracker options."]
pub type celix_bundle_tracking_options_t = celix_bundle_tracker_options;
extern "C" {
    #[doc = " @brief Tracks bundles using the provided bundle tracker options.\n\n The tracker options are only using during this call and can safely be freed/reused after this call returns.\n (i.e. can be on the stack)\n\n The bundle tracker will be created async on the Celix event loop thread. This means that the function can return\n before the tracker is created.\n\n @param ctx   The bundle context.\n @param opts  The pointer to the bundle tracker options.\n @return      The bundle tracker id (>=0) or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackBundlesWithOptionsAsync(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_bundle_tracking_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Tracks bundles using the provided bundle tracker options.\n\n The tracker options are only using during this call and can safely be freed/reused after this call returns.\n (i.e. can be on the stack)\n\n Note: please use celix_bundleContext_trackBundlesWithOptionsAsync instead;\n\n @param ctx   The bundle context.\n @param opts  The pointer to the bundle tracker options.\n @return      The bundle tracker id (>=0) or < 0 if unsuccessful."]
    pub fn celix_bundleContext_trackBundlesWithOptions(
        ctx: *mut celix_bundle_context_t,
        opts: *const celix_bundle_tracking_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Use the bundle with the provided bundle id.\n\n The provided callback will be called if the bundle is found (installed).\n Call with CELIX_FRAMEWORK_BUNDLE_ID as bundleId to use the framework bundle.\n\n @param ctx               The bundle context.\n @param bundleId          The bundle id.\n @param callbackHandle    The data pointer, which will be used in the callbacks\n @param use               The callback which will be called for the currently started bundles.\n                          The bundle pointers are only guaranteed to be valid during the callback.\n @return                  Returns true if the bundle is found and the callback is called."]
    pub fn celix_bundleContext_useBundle(
        ctx: *mut celix_bundle_context_t,
        bundleId: ::std::os::raw::c_long,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                bundle: *const celix_bundle_t,
            ),
        >,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Use the currently installed bundles.\n\n The provided callback will be called for all the currently installed bundles, expect the framework bundle.\n\n @param ctx               The bundle context.\n @param callbackHandle    The data pointer, which will be used in the callbacks\n @param use               The callback which will be called for the currently started bundles.\n                          The bundle pointers are only guaranteed to be valid during the callback.\n @return                  The number of times the use callback is called (nr of installed bundles)."]
    pub fn celix_bundleContext_useBundles(
        ctx: *mut celix_bundle_context_t,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                bundle: *const celix_bundle_t,
            ),
        >,
    ) -> usize;
}
#[doc = " @brief Service Tracker Info provided to the service tracker tracker callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_service_tracker_info {
    #[doc = " @brief The parsed service filter, e.g. parsed \"(&(objectClass=example_calc)(meta.info=foo))\""]
    pub filter: *mut celix_filter_t,
    #[doc = " @brief The service name filter attribute parsed from the service filter (i.e. the value of the objectClass attribute key)"]
    pub serviceName: *const ::std::os::raw::c_char,
    #[doc = " @brief Bundle id of the owner of the service tracker."]
    pub bundleId: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_celix_service_tracker_info() {
    const UNINIT: ::std::mem::MaybeUninit<celix_service_tracker_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_service_tracker_info>(),
        24usize,
        concat!("Size of: ", stringify!(celix_service_tracker_info))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_service_tracker_info>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_service_tracker_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracker_info),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracker_info),
            "::",
            stringify!(serviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bundleId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_service_tracker_info),
            "::",
            stringify!(bundleId)
        )
    );
}
#[doc = " @brief Service Tracker Info provided to the service tracker tracker callbacks."]
pub type celix_service_tracker_info_t = celix_service_tracker_info;
extern "C" {
    #[doc = " @brief Track the service tracker targeting the provided service name.\n\n This can be used to track if there is an interest in a certain service and ad-hoc act on that interest.\n\n Note that the celix_service_tracker_info_t pointer in the trackerAdd/trackerRemove callbacks are only valid during\n the callback.\n\n This tracker can be stopped with the celix_bundleContext_stopTracker function.\n\n The service tracker tracker will be created async on the Celix event loop thread. This means that the function can return\n before the tracker is created.\n\n @param ctx The bundle context\n @param serviceName The target service name for the service tracker to track.\n                      If NULL is provided, add/remove callbacks will be called for all service trackers in the framework.\n @param callbackHandle The callback handle which will be provided as handle in the trackerAdd and trackerRemove callback.\n @param trackerAdd Called when a service tracker is added, which tracks the provided service name. Will also be called\n                   for all existing service tracker when this tracker is started.\n @param trackerRemove Called when a service tracker is removed, which tracks the provided service name\n @param doneCallbackData call back data argument provided to the done callback function.\n @param doneCallback If not NULL will be called when the service tracker tracker is created.\n                          If a asyns track service is combined with a _sync_ stop tracker, it can happen that\n                          \"stop tracker\" happens before the \"create tracker\" event is processed.\n                          In this case the doneCallback will not be called.\n @return The tracker id or <0 if something went wrong (will log an error)."]
    pub fn celix_bundleContext_trackServiceTrackersAsync(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
        callbackHandle: *mut ::std::os::raw::c_void,
        trackerAdd: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                info: *const celix_service_tracker_info_t,
            ),
        >,
        trackerRemove: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                info: *const celix_service_tracker_info_t,
            ),
        >,
        doneCallbackData: *mut ::std::os::raw::c_void,
        doneCallback: ::std::option::Option<
            unsafe extern "C" fn(doneCallbackData: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Track the service tracker targeting the provided service name.\n\n This can be used to track if there is an interest in a certain service and ad-hoc act on that interest.\n\n Note that the celix_service_tracker_info_t pointer in the trackerAdd/trackerRemove callbacks are only valid during\n the callback.\n\n Note: Please use celix_bundleContext_trackServiceTrackersAsync instead.\n\n This tracker can be stopped with the celix_bundleContext_stopTracker function.\n\n @param ctx The bundle context.\n @param serviceName The target service name for the service tracker to track.\n                      If NULL is provided, add/remove callbacks will be called for all service trackers in the framework.\n @param callbackHandle The callback handle which will be provided as handle in the trackerAdd and trackerRemove callback.\n @param trackerAdd Called when a service tracker is added, which tracks the provided service name. Will also be called\n                   for all existing service tracker when this tracker is started.\n @param trackerRemove Called when a service tracker is removed, which tracks the provided service name\n @return The tracker id or <0 if something went wrong (will log an error)."]
    pub fn celix_bundleContext_trackServiceTrackers(
        ctx: *mut celix_bundle_context_t,
        serviceName: *const ::std::os::raw::c_char,
        callbackHandle: *mut ::std::os::raw::c_void,
        trackerAdd: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                info: *const celix_service_tracker_info_t,
            ),
        >,
        trackerRemove: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                info: *const celix_service_tracker_info_t,
            ),
        >,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Gets the dependency manager for this bundle context.\n\n @return the dependency manager or NULL if unsuccessful."]
    pub fn celix_bundleContext_getDependencyManager(
        ctx: *mut celix_bundle_context_t,
    ) -> *mut celix_dependency_manager_t;
}
extern "C" {
    #[doc = " @brief Wait until all Celix event for this bundle are completed."]
    pub fn celix_bundleContext_waitForEvents(ctx: *mut celix_bundle_context_t);
}
#[doc = " @struct celix_scheduled_event_options\n @brief Celix scheduled event options, used for creating scheduling events with the celix framework."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_scheduled_event_options {
    #[doc = "<\n @brief The name of the event, used for logging and debugging.\n\n Expected to be const char* that is valid during the celix_bundleContext_scheduleEvent\n call. Can be NULL."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< @brief Initial delay in seconds before the event is processed."]
    pub initialDelayInSeconds: f64,
    #[doc = "< @brief Schedule interval in seconds.\n  0 means one-shot scheduled event."]
    pub intervalInSeconds: f64,
    #[doc = "< @brief Data passed to the callback function when a event is scheduled."]
    pub callbackData: *mut ::std::os::raw::c_void,
    #[doc = "< @brief Callback function called to process a scheduled\nevent. Will be called on the event thread."]
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(callbackData: *mut ::std::os::raw::c_void)>,
    pub removeCallbackData: *mut ::std::os::raw::c_void,
    pub removeCallback: ::std::option::Option<
        unsafe extern "C" fn(removeCallbackData: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_celix_scheduled_event_options() {
    const UNINIT: ::std::mem::MaybeUninit<celix_scheduled_event_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_scheduled_event_options>(),
        56usize,
        concat!("Size of: ", stringify!(celix_scheduled_event_options))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_scheduled_event_options>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_scheduled_event_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialDelayInSeconds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(initialDelayInSeconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intervalInSeconds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(intervalInSeconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(callbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removeCallbackData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(removeCallbackData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removeCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_scheduled_event_options),
            "::",
            stringify!(removeCallback)
        )
    );
}
#[doc = " @struct celix_scheduled_event_options\n @brief Celix scheduled event options, used for creating scheduling events with the celix framework."]
pub type celix_scheduled_event_options_t = celix_scheduled_event_options;
extern "C" {
    #[doc = " @brief Add a scheduled event to the Celix framework.\n\n The scheduled event will be called on the Celix framework event thread, repeatedly using the provided interval or\n once if only a initial delay is provided.\n The event callback should be relatively fast and the scheduled event interval should be relatively long, otherwise\n the framework event queue will be blocked and framework will not function properly.\n\n Scheduled events can be scheduled later than the provided initial delay and interval, because they are processed\n after other events in the Celix event thread.\n The target - but not guaranteed - precision of the scheduled event trigger is 1 microsecond.\n\n If the provided interval is 0, the scheduled event will a one-shot scheduled event and will be called once\n after the provided initial delay. If a bundle stops before the one-shot scheduled event is called, the scheduled\n event will be removed and not called.\n\n Scheduled events should be removed by the caller when not needed anymore, except for one-shot scheduled events.\n one-shot are automatically removed after the event callback is called.\n\n Note during bundle stop the framework will check if all scheduled events for the bundle are removed.\n For every not removed scheduled event that is not a one-shot event, a warning will be logged and the\n scheduled event will be removed.\n\n @param[in] ctx The bundle context.\n @param[in] options The scheduled event options, which describe the to be added scheduled event.\n @return The scheduled event id of the scheduled event. Can be used to cancel the event.\n @retval <0 If the event could not be added."]
    pub fn celix_bundleContext_scheduleEvent(
        ctx: *mut celix_bundle_context_t,
        options: *const celix_scheduled_event_options_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Wakeup a scheduled event and returns immediately, not waiting for the scheduled event callback to be\n called.\n\n Silently ignored if the scheduled event ids < 0.\n\n @param[in] ctx The bundle context.\n @param[in] scheduledEventId The scheduled event id to wakeup.\n @return CELIX_SUCCESS if the scheduled event is woken up, CELIX_ILLEGAL_ARGUMENT if the scheduled event id is not known."]
    pub fn celix_bundleContext_wakeupScheduledEvent(
        ctx: *mut celix_bundle_context_t,
        scheduledEventId: ::std::os::raw::c_long,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Wait until the next scheduled event is processed.\n\n Silently ignored if the scheduled event ids < 0.\n\n @param[in] ctx The bundle context.\n @param[in] scheduledEventId The scheduled event id to wait for.\n @param[in] waitTimeInSeconds The maximum time to wait for the next scheduled event. If <= 0 the function will return\n                             immediately.\n @return CELIX_SUCCESS if the scheduled event is woken up, CELIX_ILLEGAL_ARGUMENT if the scheduled event id is not\n         known and ETIMEDOUT if the waitTimeInSeconds is reached."]
    pub fn celix_bundleContext_waitForScheduledEvent(
        ctx: *mut celix_bundle_context_t,
        scheduledEventId: ::std::os::raw::c_long,
        waitTimeInSeconds: f64,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief Cancel and remove a scheduled event.\n\n Silently ignored if the scheduled event ids < 0.\n\n This function will block until a possible in-progress scheduled event callback is finished, the scheduled event\n is removed and, if configured, the remove callback is called.\n\n @param[in] ctx The bundle context.\n @param[in] scheduledEventId The scheduled event id to cancel and remove.\n @return true if a scheduled event is cancelled, false if the scheduled event id is not known."]
    pub fn celix_bundleContext_removeScheduledEvent(
        ctx: *mut celix_bundle_context_t,
        scheduledEventId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Cancel and remove a scheduled event asynchronously.\n\n When this function returns, no new scheduled event callbacks will be called, but it is not guaranteed that there\n is still a scheduled event callback in progress and that the remove callback is called.\n\n Silently ignored if the scheduled event ids < 0.\n\n @param[in] ctx The bundle context.\n @param[in] scheduledEventId The scheduled event id to cancel and remove.\n @return true if a scheduled event is cancelled, false if the scheduled event id is not known."]
    pub fn celix_bundleContext_removeScheduledEventAsync(
        ctx: *mut celix_bundle_context_t,
        scheduledEventId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Try to cancel and remove a scheduled event asynchronously.\n\n Silently ignored if the scheduled event ids < 0.\n\n When this function returns, no new scheduled event callbacks will be called, but it is not guaranteed that there\n is still a scheduled event callback in progress and that the remove callback is called.\n Will not log an error if the scheduled event id is not known.\n\n @param[in] ctx The bundle context.\n @param[in] scheduledEventId The scheduled event id to cancel.\n @return true if a scheduled event is cancelled, false if the scheduled event id is not known."]
    pub fn celix_bundleContext_tryRemoveScheduledEventAsync(
        ctx: *mut celix_bundle_context_t,
        scheduledEventId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the bundle for this bundle context."]
    pub fn celix_bundleContext_getBundle(ctx: *const celix_bundle_context_t)
        -> *mut celix_bundle_t;
}
extern "C" {
    #[doc = " @brief Returns the bundle if for the bundle of this bundle context."]
    pub fn celix_bundleContext_getBundleId(
        ctx: *const celix_bundle_context_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn celix_bundleContext_getFramework(
        ctx: *const celix_bundle_context_t,
    ) -> *mut celix_framework_t;
}
extern "C" {
    #[doc = " @brief Logs a message to Celix framework logger with the provided log level.\n @param ctx       The bundle context\n @param level     The log level to use\n @param format    printf style format string\n @param ...       printf style format arguments"]
    pub fn celix_bundleContext_log(
        ctx: *const celix_bundle_context_t,
        level: celix_log_level_e,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @brief Logs a message to Celix framework logger with the provided log level."]
    pub fn celix_bundleContext_vlog(
        ctx: *const celix_bundle_context_t,
        level: celix_log_level_e,
        format: *const ::std::os::raw::c_char,
        formatArgs: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " @brief Logs celix thread-specific storage error messages(celix_err) ith the provided celix log level.\n Silently ignores log level CELIX_LOG_LEVEL_DISABLED."]
    pub fn celix_bundleContext_logTssErrors(
        ctx: *const celix_bundle_context_t,
        level: celix_log_level_e,
    );
}
extern "C" {
    #[doc = " @brief Get the config property for the given key.\n\n The config property is a property from the framework configuration or a system property.\n If a system property is found, the system property is returned.\n Otherwise the framework configuration property - if found - is returned.\n\n @param ctx The bundle context.\n @param name The name of the property.\n @param defaultValue The default value if the property is not found.\n @return The property value or the default value if the property is not found."]
    pub fn celix_bundleContext_getProperty(
        ctx: *mut celix_bundle_context_t,
        key: *const ::std::os::raw::c_char,
        defaultVal: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the config property for the given key converted as long value.\n\n The config property is a property from the framework configuration or a system property.\n If a system property is found, the system property is returned.\n Otherwise the framework configuration property - if found - is returned.\n\n @param framework The framework.\n @param name The name of the property.\n @param defaultValue The default value if the property is not found.\n @return The property value or the default value if the property is not found or the property value cannot be converted\n         to a long value."]
    pub fn celix_bundleContext_getPropertyAsLong(
        ctx: *mut celix_bundle_context_t,
        name: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the config property for the given key converted as double value.\n\n The config property is a property from the framework configuration or a system property.\n If a system property is found, the system property is returned.\n Otherwise the framework configuration property - if found - is returned.\n\n @param framework The framework.\n @param name The name of the property.\n @param defaultValue The default value if the property is not found.\n @return The property value or the default value if the property is not found or the property value cannot be converted\n         to a double value."]
    pub fn celix_bundleContext_getPropertyAsDouble(
        ctx: *mut celix_bundle_context_t,
        name: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Get the config property for the given key converted as bool value.\n\n The config property is a property from the framework configuration or a system property.\n If a system property is found, the system property is returned.\n Otherwise the framework configuration property - if found - is returned.\n\n @param framework The framework.\n @param name The name of the property.\n @param defaultValue The default value if the property is not found.\n @return The property value or the default value if the property is not found or the property value cannot be converted\n         to a bool value."]
    pub fn celix_bundleContext_getPropertyAsBool(
        ctx: *mut celix_bundle_context_t,
        name: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the framework UUID. This is unique for every created framework and will not be the same if the process is\n restarted."]
    pub fn celix_framework_getUUID(fw: *const celix_framework_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the framework bundle context. This is the same as a 'normal' bundle context and can be used to register, use\n and track services. The only difference is that the framework is the bundle.\n @param fw The framework\n @return A pointer to the bundle context of the framework or NULL if something went wrong."]
    pub fn celix_framework_getFrameworkContext(
        fw: *const celix_framework_t,
    ) -> *mut celix_bundle_context_t;
}
extern "C" {
    #[doc = " @brief Returns the framework bundle. This is the same as a 'normal' bundle, expect that this bundle cannot be uninstalled\n and the `celix_bundle_getEntry` return a entries relative from the working directory.\n @param fw The framework\n @return A pointer to the bundle of the framework or NULL if something went wrong."]
    pub fn celix_framework_getFrameworkBundle(fw: *const celix_framework_t) -> *mut celix_bundle_t;
}
extern "C" {
    #[doc = " @brief Use the currently installed bundles.\n The provided callback will be called for all the currently installed bundles.\n\n @warning It is dangerous to use the provided bundle's context from the callback, since it may be invalid for an inactive bundle.\n\n @param fw                        The framework.\n @param includeFrameworkBundle    If true the callback will also be triggered for the framework bundle.\n @param callbackHandle            The data pointer, which will be used in the callbacks\n @param use                       The callback which will be called for the currently installed bundles.\n                                  The bundle pointers are only guaranteed to be valid during the callback.\n @return                          The number of times the use callback is called."]
    pub fn celix_framework_useBundles(
        fw: *mut celix_framework_t,
        includeFrameworkBundle: bool,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, bnd: *const celix_bundle_t),
        >,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Use the currently active bundles.\n The provided callback will be called for all the currently active bundles.\n The bundle state is guaranteed to be active during the callback.\n\n @warning Calling synchronous bundle-state changing functions (e.g. celix_bundleContext_stopBundle) from the callback\n will lead to deadlocks.\n\n @param fw                        The framework.\n @param includeFrameworkBundle    If true the callback will also be triggered for the framework bundle.\n @param callbackHandle            The data pointer, which will be used in the callbacks\n @param use                       The callback which will be called for the currently active bundles.\n @return                          The number of times the use callback is called."]
    pub fn celix_framework_useActiveBundles(
        fw: *mut celix_framework_t,
        includeFrameworkBundle: bool,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, bnd: *const celix_bundle_t),
        >,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Use the bundle with the provided bundle id\n The provided callback will be called if the bundle is found.\n\n @warning Calling synchronous bundle-state changing functions (e.g. celix_bundleContext_stopBundle) with onlyActive=true\n from the callback will lead to deadlocks. Using a bundle's context, e.g. calling celix_bundle_listServiceTrackers,\n with onlyActive=false from the callback is generally dangerous. However, in some cases, the target bundle's context is guaranteed to be valid,\n e.g. the bundle is providing a service protected by a service tracker.\n\n @param fw                The framework.\n @param onlyActive        If true only starting and active bundles will trigger the callback.\n @param bundleId          The bundle id.\n @param callbackHandle    The data pointer, which will be used in the callbacks\n @param use               The callback which will be called for the currently started bundles.\n                          The bundle pointers are only guaranteed to be valid during the callback.\n @return                  Returns true if the bundle is found and the callback is called."]
    pub fn celix_framework_useBundle(
        fw: *mut celix_framework_t,
        onlyActive: bool,
        bndId: ::std::os::raw::c_long,
        callbackHandle: *mut ::std::os::raw::c_void,
        use_: ::std::option::Option<
            unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void, bnd: *const celix_bundle_t),
        >,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check whether a bundle is installed.\n @param fw        The Celix framework\n @param bndId     The bundle id to check\n @return          true if the bundle is installed."]
    pub fn celix_framework_isBundleInstalled(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check whether the bundle is active.\n @param fw        The Celix framework\n @param bndId     The bundle id to check\n @return          true if the bundle is installed and active."]
    pub fn celix_framework_isBundleActive(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Install and optional start a bundle.\n Will silently ignore bundle ids < 0.\n\n @param fw The Celix framework\n @param bundleLoc The bundle location to the bundle zip file.\n @param autoStart If the bundle should also be started.\n @return the bundleId (>= 0) or < 0 if the bundle could not be installed and possibly started."]
    pub fn celix_framework_installBundle(
        fw: *mut celix_framework_t,
        bundleLoc: *const ::std::os::raw::c_char,
        autoStart: bool,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Uninstall the bundle with the provided bundle id. If needed the bundle will be stopped first.\n Will silently ignore bundle ids < 0.\n\n @param fw The Celix framework\n @param bndId The bundle id to uninstall.\n @return true if the bundle is correctly uninstalled. False if not."]
    pub fn celix_framework_uninstallBundle(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Unload the bundle with the provided bundle id. If needed the bundle will be stopped first.\n Will silently ignore bundle ids < 0.\n Note that unloaded bundle is kept in bundle cache and can be reloaded with the celix_framework_installBundle function.\n\n @param fw The Celix framework\n @param bndId The bundle id to unload.\n @return true if the bundle is correctly unloaded. False if not."]
    pub fn celix_framework_unloadBundle(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Update the bundle with the provided bundle id.\n\n This will do the following:\n  - unload the bundle with the specified bundle id;\n  - reload the bundle from the specified location with the specified bundle id;\n  - start the bundle, if it was previously active.\n\n  Will silently ignore bundle ids < 0.\n\n  Note if specified bundle location already exists in the bundle cache but with a different bundle id, the bundle\n  will NOT be reloaded, and the update is cancelled.\n\n @param [in] fw The Celix framework\n @param [in] bndId the bundle id to update.\n @param [in] updatedBundleUrl The optional updated bundle url to the bundle zip file.\n If NULL, the existing bundle url from the bundle cache will be used, and the cache will only be updated if the zip file is newer.\n @return true if the bundle is correctly updated. False if not."]
    pub fn celix_framework_updateBundle(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
        updatedBundleUrl: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Stop the bundle with the provided bundle id.\n Will silently ignore bundle ids < 0.\n\n @param fw The Celix framework\n @param bndId The bundle id to stop.\n @return true if the bundle is found & correctly stop. False if not."]
    pub fn celix_framework_stopBundle(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Start the bundle with the provided bundle id.\n Will silently ignore bundle ids < 0.\n\n @param fw The Celix framework\n @param bndId The bundle id to start.\n @return true if the bundle is found & correctly started. False if not."]
    pub fn celix_framework_startBundle(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Install and optional start a bundle async.\n Will silently ignore bundle ids < 0.\n\n If the bundle needs to be started this will be done a separate spawned thread.\n\n @param fw The Celix framework\n @param bundleLoc The bundle location to the bundle zip file.\n @param autoStart If the bundle should also be started.\n @return The bundle id of the installed bundle or -1 if the bundle could not be installed"]
    pub fn celix_framework_installBundleAsync(
        fw: *mut celix_framework_t,
        bundleLoc: *const ::std::os::raw::c_char,
        autoStart: bool,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Update the bundle with the provided bundle id async.\n\n This will do the following:\n  - unload the bundle with the specified bundle id;\n  - reload the bundle from the specified location with the specified bundle id;\n  - start the bundle, if it was previously active.\n\n  Will silently ignore bundle ids < 0.\n\n  Note if specified bundle location already exists in the bundle cache but with a different bundle id, the bundle\n  will NOT be reinstalled, and the update is cancelled.\n\n @param [in] fw The Celix framework\n @param [in] bndId the bundle id to update.\n @param [in] updatedBundleUrl The optional updated bundle url to the bundle zip file.\n If NULL, the existing bundle url from the bundle cache will be used, and the cache will only be updated if the zip file is newer."]
    pub fn celix_framework_updateBundleAsync(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
        updatedBundleUrl: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Uninstall the bundle with the provided bundle id async. If needed the bundle will be stopped first.\n Will silently ignore bundle ids < 0.\n\n The bundle will be uninstalled on a separate spawned thread.\n\n @param fw The Celix framework\n @param bndId The bundle id to uninstall."]
    pub fn celix_framework_uninstallBundleAsync(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Unload the bundle with the provided bundle id async. If needed the bundle will be stopped first.\n Will silently ignore bundle ids < 0.\n Note that unloaded bundle is kept in bundle cache and can be reloaded with the celix_framework_installBundle function.\n The bundle will be unloaded on a separate spawned thread.\n\n @param fw The Celix framework\n @param bndId The bundle id to unload."]
    pub fn celix_framework_unloadBundleAsync(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Stop the bundle with the provided bundle id async.\n Will silently ignore bundle ids < 0.\n\n The bundle will be stopped on a separate spawned thread.\n\n @param fw The Celix framework\n @param bndId The bundle id to stop."]
    pub fn celix_framework_stopBundleAsync(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Start the bundle with the provided bundle id async.\n Will silently ignore bundle ids < 0.\n\n The bundle will be started on a separate spawned thread.\n\n @param fw The Celix framework\n @param bndId The bundle id to start."]
    pub fn celix_framework_startBundleAsync(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief List the installed and started bundle ids.\n The bundle ids does not include the framework bundle (bundle id CELIX_FRAMEWORK_BUNDLE_ID).\n\n @param framework The Celix framework.\n @return A array with bundle ids (long). The caller is responsible for destroying the array."]
    pub fn celix_framework_listBundles(
        framework: *mut celix_framework_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief List the installed bundle ids.\n The bundle ids does not include the framework bundle (bundle id CELIX_FRAMEWORK_BUNDLE_ID).\n\n @param framework The Celix framework.\n @return A array with bundle ids (long). The caller is responsible for destroying the array."]
    pub fn celix_framework_listInstalledBundles(
        framework: *mut celix_framework_t,
    ) -> *mut celix_array_list_t;
}
extern "C" {
    #[doc = " @brief Sets the log function for this framework.\n Default the celix framework will log to stdout/stderr.\n\n A log function can be injected to change how the Celix framework logs.\n Can be reset by setting the log function to NULL."]
    pub fn celix_framework_setLogCallback(
        fw: *mut celix_framework_t,
        logHandle: *mut ::std::os::raw::c_void,
        logFunction: ::std::option::Option<
            unsafe extern "C" fn(
                handle: *mut ::std::os::raw::c_void,
                level: celix_log_level_e,
                file: *const ::std::os::raw::c_char,
                function: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
                format: *const ::std::os::raw::c_char,
                formatArgs: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    #[doc = " @brief Wait until the framework event queue is empty.\n\n The Celix framework has an event queue which (among others) handles various events.\n This function can be used to ensure that all queue events are handled.\n\n Note scheduled events are not part of the event queue.\n\n @param fw The Celix Framework"]
    pub fn celix_framework_waitForEmptyEventQueue(fw: *mut celix_framework_t);
}
extern "C" {
    #[doc = " @brief Wait until the framework event queue is empty or the provided period is reached.\n\n The Celix framework has an event queue which (among others) handles various events.\n This function can be used to ensure that all queue events are handled.\n\n Note scheduled events are not part of the event queue.\n\n @param[in] fw The Celix Framework.\n @param[in] timeoutInSeconds The period in seconds to wait for the event queue to be empty. 0 means wait forever.\n @return CELIX_SUCCESS if the event queue is empty or ETIMEDOUT if the timeoutInSeconds is reached."]
    pub fn celix_framework_waitForEmptyEventQueueFor(
        fw: *mut celix_framework_t,
        timeoutInSeconds: f64,
    ) -> celix_status_t;
}
extern "C" {
    #[doc = " @brief wait until all events from the event queue for the bundle identified by the bndId are processed.\n\n If bndId < 0, wait until all bundle events (events associated with a bundle) from the event queue are processed.\n Note scheduled events are not part of the event queue.\n"]
    pub fn celix_framework_waitUntilNoEventsForBnd(
        fw: *mut celix_framework_t,
        bndId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief wait until all pending service registration are processed."]
    pub fn celix_framework_waitUntilNoPendingRegistration(fw: *mut celix_framework_t);
}
extern "C" {
    #[doc = " @brief Returns whether the current thread is the Celix framework event loop thread.\n"]
    pub fn celix_framework_isCurrentThreadTheEventLoop(fw: *mut celix_framework_t) -> bool;
}
extern "C" {
    #[doc = " @brief Fire a generic event. The event will be added to the event loop and handled on the event loop thread.\n\n The process callback should be fast and non-blocking, otherwise\n the framework event queue will be blocked and framework will not function properly.\n\n if bndId >=0 the bundle usage count will be increased while the event is not yet processed or finished processing.\n The name is expected to be const char* valid during til the event is finished processing.\n\n if eventId >=0 this will be used, otherwise a new event id will be generated\n return eventId"]
    pub fn celix_framework_fireGenericEvent(
        fw: *mut celix_framework_t,
        eventId: ::std::os::raw::c_long,
        bndId: ::std::os::raw::c_long,
        eventName: *const ::std::os::raw::c_char,
        processData: *mut ::std::os::raw::c_void,
        processCallback: ::std::option::Option<
            unsafe extern "C" fn(data: *mut ::std::os::raw::c_void),
        >,
        doneData: *mut ::std::os::raw::c_void,
        doneCallback: ::std::option::Option<
            unsafe extern "C" fn(doneData: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Get the next event id.\n\n This can be used to ensure celix_framework_waitForGenericEvent can be used to wait for an event.\n The returned event id will not be used by the framework itself unless followed up with a\n celix_framework_fireGenericEvent call using the returned event id."]
    pub fn celix_framework_nextEventId(fw: *mut celix_framework_t) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Wait until a event from the event queue with the provided event id is completely handled.\n This function will directly return if the provided event id is not in the event loop (already done or never issued).\n\n Note scheduled events are not part of the event queue."]
    pub fn celix_framework_waitForGenericEvent(
        fw: *mut celix_framework_t,
        eventId: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " @brief Wait until the framework is stopped."]
    pub fn celix_framework_waitForStop(framework: *mut celix_framework_t);
}
extern "C" {
    #[doc = " @brief Check if the event queue is empty."]
    pub fn celix_framework_isEventQueueEmpty(fw: *mut celix_framework_t) -> bool;
}
extern "C" {
    #[doc = " Creates a new framework. The framework will be in the started state.\n @param[in] config The framework configuration. Can be NULL. This call will take ownership of the config and\n                   also destroy it when the call fails.\n @return a started framework or NULL. If NULL is returned the framework is not started."]
    pub fn celix_frameworkFactory_createFramework(
        config: *mut celix_properties_t,
    ) -> *mut celix_framework_t;
}
extern "C" {
    #[doc = " Stop and destroys a Celix framework\n Note that this call block till the Celix framework is stopped"]
    pub fn celix_frameworkFactory_destroyFramework(fw: *mut celix_framework_t);
}
extern "C" {
    #[doc = " @brief Install bundles to the provided framework using the provided bundle set.\n\n Bundles will be installed in the order they appear in the provided bundleSet.\n If autStart is true, all bundles will be installed first and then started in the same order.\n\n The bundle set should be `,` separated set of bundle urls. Example:\n \\code\n const char* bundleSet = \"file:///usr/local/share/celix/bundles/celix_shell.zip,embedded://example_bundle\";\n \\endcode\n\n This function is designed to be used in combination with the Celix CMake command\n `celix_target_bundle_set_definition`.\n\n @param fw The Celix framework used to install the bundles.\n @param bundleSet A set of `,` seperated bundles urls.\n @param autoStart Whether to also start the installed bundles.\n @return The number of installed bundles."]
    pub fn celix_framework_utils_installBundleSet(
        fw: *mut celix_framework_t,
        bundleSet: *const ::std::os::raw::c_char,
        autoStart: bool,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Create the bundle archives cache for the provided framework, but do not install or start the bundles.\n\n This function can be used to preconfigure a application, so that during startup no bundle zip extraction is needed.\n\n @param fw The Celix framework used to create the bundle archives cache.\n @return CELIX_SUCCESS if the bundle archives cache is created successfully."]
    pub fn celix_framework_utils_createBundleArchivesCache(
        fw: *mut celix_framework_t,
    ) -> celix_status_t;
}
#[doc = " The shell command can be used to register additional shell commands.\n This service should be registered with the following properties:\n  - command.name: mandatory, name of the command e.g. 'lb'\n  - command.usage: optional, string describing how tu use the command e.g. 'lb [-l | -s | -u]'\n  - command.description: optional, string describing the command e.g. 'list bundles.'"]
pub type celix_shell_command_t = celix_shell_command;
#[doc = " The shell command can be used to register additional shell commands.\n This service should be registered with the following properties:\n  - command.name: mandatory, name of the command e.g. 'lb'\n  - command.usage: optional, string describing how tu use the command e.g. 'lb [-l | -s | -u]'\n  - command.description: optional, string describing the command e.g. 'list bundles.'"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_shell_command {
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Calls the shell command.\n @param handle        The shell command handle.\n @param commandLine   The complete provided cmd line (e.g. for a 'stop' command -> 'stop 42')\n @param outStream     The output stream, to use for printing normal flow info.\n @param errorStream   The error stream, to use for printing error flow info.\n @return              Whether a command is successfully executed."]
    pub executeCommand: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            commandLine: *const ::std::os::raw::c_char,
            outStream: *mut FILE,
            errorStream: *mut FILE,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_celix_shell_command() {
    const UNINIT: ::std::mem::MaybeUninit<celix_shell_command> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_shell_command>(),
        16usize,
        concat!("Size of: ", stringify!(celix_shell_command))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_shell_command>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_shell_command))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_shell_command),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).executeCommand) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_shell_command),
            "::",
            stringify!(executeCommand)
        )
    );
}
#[doc = " Celix log service. The log service can be requested for logging purpose.\n\n When requesting this service a name can be used in the service filter. If the name is present,\n a logging instance for that name will be created.\n\n Names can be used to create a hierarchy for loggers, e.g.:\n - (name=celix_pubsub_PubSubTcpAdmin)\n - (name=celix_pubsub_PubSubZqmAdmin)\n - (name=celix_HttpAdmin)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct celix_log_service {
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Logs a trace message, printf style."]
    pub trace: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a debug message, printf style."]
    pub debug: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a info message, printf style."]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a warning message, printf style."]
    pub warning: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a error message, printf style."]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a fatal message, printf style."]
    pub fatal: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a message using the provided log level, printf style\n Silently ignores log level CELIX_LOG_LEVEL_DISABLED."]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            level: celix_log_level_e,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Logs a message using the provided log level, printf style\n Silently ignores log level CELIX_LOG_LEVEL_DISABLED.\n\n The file, function and line arguments are expected to be called with the values:\n __FILE__, __FUNCTION__ and __LINE__.\n\n If the argument file or function is NULL, the arguments file, function and line are not used."]
    pub logDetails: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            level: celix_log_level_e,
            file: *const ::std::os::raw::c_char,
            function: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            format: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message using a format string and va_list argument (vprintf style)\n Silently ignores log level CELIX_LOG_LEVEL_DISABLED."]
    pub vlog: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            level: celix_log_level_e,
            format: *const ::std::os::raw::c_char,
            formatArgs: *mut __va_list_tag,
        ),
    >,
    #[doc = " Log a detailed message using a format string and va_list argument (vprintf style)\n Silently ignores log level CELIX_LOG_LEVEL_DISABLED.\n\n The file, function and line arguments are expected to be called with the values:\n __FILE__, __FUNCTION__ and __LINE__.\n\n If the argument file or function is NULL, the arguments file, function and line are not used."]
    pub vlogDetails: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            level: celix_log_level_e,
            file: *const ::std::os::raw::c_char,
            function: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            format: *const ::std::os::raw::c_char,
            formatArgs: *mut __va_list_tag,
        ),
    >,
}
#[test]
fn bindgen_test_layout_celix_log_service() {
    const UNINIT: ::std::mem::MaybeUninit<celix_log_service> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<celix_log_service>(),
        88usize,
        concat!("Size of: ", stringify!(celix_log_service))
    );
    assert_eq!(
        ::std::mem::align_of::<celix_log_service>(),
        8usize,
        concat!("Alignment of ", stringify!(celix_log_service))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(trace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warning) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(warning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fatal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(fatal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logDetails) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(logDetails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlog) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(vlog)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlogDetails) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(celix_log_service),
            "::",
            stringify!(vlogDetails)
        )
    );
}
#[doc = " Celix log service. The log service can be requested for logging purpose.\n\n When requesting this service a name can be used in the service filter. If the name is present,\n a logging instance for that name will be created.\n\n Names can be used to create a hierarchy for loggers, e.g.:\n - (name=celix_pubsub_PubSubTcpAdmin)\n - (name=celix_pubsub_PubSubZqmAdmin)\n - (name=celix_HttpAdmin)"]
pub type celix_log_service_t = celix_log_service;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
